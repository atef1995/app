---
title: "Asynchronous JavaScript Mastery"
description: "Master async programming with callbacks, promises, async/await, and modern JavaScript patterns"
level: "advanced"
estimatedTime: "60 minutes"
topics: ["Promises", "Async/Await", "Fetch API", "Error Handling", "Concurrency", "Event Loop"]
quizQuestions: 15
order: 4
---

# Asynchronous JavaScript Mastery

Hey there, future async wizard! üßô‚Äç‚ôÇÔ∏è Ready to dive into one of JavaScript's most powerful (and sometimes mind-bending) features? 

I still remember the first time I encountered asynchronous JavaScript. I was building a simple app that needed to fetch user data, and my code kept executing in the wrong order. Sound familiar? By the end of this tutorial, you'll not only understand why that happens but master the elegant solutions JavaScript provides.

**Here's what we're going to explore together:**
- Why async programming exists (and why your brain might hurt at first!)
- The evolution from "callback hell" to beautiful async/await
- Real-world patterns you'll actually use in your projects
- Performance tricks that'll make your apps lightning fast

Let's start with a question: **Have you ever wondered why JavaScript can handle multiple things at once when it's supposedly "single-threaded"?** ü§î

## Understanding Asynchronous Programming - The "Aha!" Moment üåä

Before we dive into code, let's clear up something that confuses everyone initially. JavaScript **IS** single-threaded, but it can handle multiple operations simultaneously. How? Through the magic of asynchronous programming!

Think of it like this: **You're a chef in a kitchen (single-threaded), but you can put multiple dishes in different ovens and check on them periodically without standing around waiting for each one to finish.**

<InteractiveCodeBlock editable={true} language="javascript" useWebContainer={true}>
{`// Let's see the event loop in action! This might surprise you...

console.log('1 - I run first (synchronous)');

setTimeout(() => {
  console.log('2 - I run third (asynchronous - macro task)');
}, 0); // Even with 0 delay!

Promise.resolve().then(() => {
  console.log('3 - I run second (asynchronous - micro task)');
});

console.log('4 - I run before the async stuff (synchronous)');

// Try to predict the output order before running!
// What do you think will happen and why?`}
</InteractiveCodeBlock>

**Whoa! Did that surprise you?** Even with a 0ms timeout, the setTimeout runs last. This is the event loop at work:

1. **Synchronous code** runs immediately
2. **Microtasks** (Promises) get priority in the queue
3. **Macrotasks** (setTimeout) run after microtasks

**Your turn to experiment!** Try changing the setTimeout delay to see if it affects the order. Then add another Promise - where does it appear in the output?

### Why This Matters - The Blocking Problem

Let me show you why async programming isn't just cool - it's essential:

<InteractiveCodeBlock editable={true} language="javascript" >
{`// üö® DON'T DO THIS - Blocking approach (simulated)
function fetchDataBlocking() {
  console.log("üîÑ Starting to fetch data...");
  
  // This simulates a blocking operation
  const start = Date.now();
  while (Date.now() - start < 2000) {
    // Blocking the entire thread for 2 seconds!
  }
  
  console.log("‚úÖ Data fetched (but everything was frozen!)");
  return "Important data";
}

// ‚úÖ NON-BLOCKING - Async approach  
function fetchDataAsync() {
  console.log("üîÑ Starting async fetch...");
  
  return new Promise(resolve => {
    setTimeout(() => {
      console.log("‚úÖ Async data fetched (thread stayed free!)");
      resolve("Important data");
    }, 2000);
  });
}

// Let's test both approaches
console.log("=== Testing Blocking Approach ===");
console.log("Before blocking call");
const blockingResult = fetchDataBlocking();
console.log("After blocking call:", blockingResult);

console.log("\\n=== Testing Async Approach ===");
console.log("Before async call");
fetchDataAsync().then(result => {
  console.log("Async result:", result);
});
console.log("After async call (this runs immediately!)");

// Notice how the blocking version freezes everything!`}
</InteractiveCodeBlock>

**See the difference?** The blocking version makes everything wait, while the async version lets other code keep running. This is why websites stay responsive even when loading data!

**Challenge time!** Add a `console.log("I can still run!")` in a loop after the async call to see how the thread stays free.

## Callbacks - Where It All Started üìû

Before Promises existed, we had callbacks. They're still important to understand because you'll see them everywhere!

**A callback is simply a function you pass to another function, saying "hey, call this when you're done."**

<InteractiveCodeBlock editable={true} language="javascript"  >
{`// Let's build a simple callback system from scratch!

// First, let's create a function that simulates fetching user data
function fetchUserData(userId, callback) {
  console.log(\`üîç Looking up user \${userId}...\`);
  
  // Simulate network delay
  setTimeout(() => {
    // Simulate different outcomes
    const success = Math.random() > 0.3; // 70% success rate
    
    if (success) {
      const userData = {
        id: userId,
        name: \`User\${userId}\`,
        email: \`user\${userId}@example.com\`,
        joinDate: '2024-01-15'
      };
      
      // Convention: callback(error, result)
      callback(null, userData); // null = no error
    } else {
      callback(new Error("User not found"), null);
    }
  }, Math.random() * 1000 + 500); // Random delay 500-1500ms
}

// Now let's use our callback-based function
console.log("Starting user lookup...");

fetchUserData(123, (error, user) => {
  if (error) {
    console.error("‚ùå Oh no!", error.message);
  } else {
    console.log("‚úÖ Got user:", user);
    console.log(\`Welcome \${user.name}!\`);
  }
});

console.log("This runs while we wait for the user data!");

// Try running this multiple times - sometimes it succeeds, sometimes it fails!`}
</InteractiveCodeBlock>

**Pretty straightforward, right?** But here's where callbacks get tricky...

### The Dreaded Callback Hell üò±

What happens when you need to fetch user data, then their posts, then comments on those posts? Let's see:

<InteractiveCodeBlock editable={true} language="javascript" >
{`// Oh no... callback hell is real! üò∞

function fetchUser(userId, callback) {
  setTimeout(() => {
    console.log(\`‚úÖ Got user \${userId}\`);
    callback(null, { id: userId, name: \`User\${userId}\` });
  }, 300);
}

function fetchUserPosts(userId, callback) {
  setTimeout(() => {
    console.log(\`‚úÖ Got posts for user \${userId}\`);
    const posts = [
      { id: 1, title: "My first post", userId },
      { id: 2, title: "Another great post", userId }
    ];
    callback(null, posts);
  }, 400);
}

function fetchPostComments(postId, callback) {
  setTimeout(() => {
    console.log(\`‚úÖ Got comments for post \${postId}\`);
    const comments = [
      { id: 1, text: "Great post!", postId },
      { id: 2, text: "Thanks for sharing!", postId }
    ];
    callback(null, comments);
  }, 200);
}

// Now watch this pyramid of doom grow! üìê
console.log("Starting the callback pyramid...");

fetchUser(1, (userError, user) => {
  if (userError) {
    console.error("User error:", userError);
  } else {
    console.log("Got user, now fetching posts...");
    
    fetchUserPosts(user.id, (postsError, posts) => {
      if (postsError) {
        console.error("Posts error:", postsError);
      } else {
        console.log("Got posts, now fetching comments...");
        
        fetchPostComments(posts[0].id, (commentsError, comments) => {
          if (commentsError) {
            console.error("Comments error:", commentsError);
          } else {
            console.log("üéâ Finally got everything!");
            console.log("User:", user.name);
            console.log("First post:", posts[0].title);
            console.log("Comments:", comments.length);
          }
        });
      }
    });
  }
});

console.log("Look at all that nesting! üèîÔ∏è");`}
</InteractiveCodeBlock>

**Yikes!** See how the code keeps moving to the right? This is callback hell - hard to read, harder to maintain, and error handling is a nightmare!

**Your challenge:** Try adding error handling for a network timeout. You'll quickly see how complex this gets!

## Promises - The Hero We Needed ü§ù

Promises were introduced to solve callback hell. **Think of a Promise as exactly what it sounds like - "I promise to give you a result eventually, either success or failure."**

A Promise has three states:
- **Pending**: "I'm still working on it..."
- **Fulfilled**: "Success! Here's your result!"
- **Rejected**: "Sorry, something went wrong."

<InteractiveCodeBlock editable={true} language="javascript" >
{`// Let's create our first Promise from scratch!

// This function returns a Promise instead of using callbacks
function fetchUserPromise(userId) {
  console.log(\`üîç Promise: Looking up user \${userId}...\`);
  
  return new Promise((resolve, reject) => {
    // Inside here, we do the async work
    setTimeout(() => {
      const success = Math.random() > 0.2; // 80% success rate
      
      if (success) {
        const userData = {
          id: userId,
          name: \`User\${userId}\`,
          email: \`user\${userId}@example.com\`,
          status: 'active'
        };
        
        console.log("‚úÖ Promise resolved!");
        resolve(userData); // Success!
      } else {
        console.log("‚ùå Promise rejected!");
        reject(new Error("User not found")); // Failure!
      }
    }, 800);
  });
}

// Now using the Promise is much cleaner!
console.log("=== Using Promises ===");

fetchUserPromise(456)
  .then(user => {
    console.log("üéâ Success! User:", user);
    return user.name; // You can return values to the next .then()
  })
  .then(userName => {
    console.log(\`Processing user: \${userName}\`);
    return userName.toUpperCase();
  })
  .then(upperName => {
    console.log(\`Shouting: \${upperName}!\`);
  })
  .catch(error => {
    console.error("üí• Something went wrong:", error.message);
  })
  .finally(() => {
    console.log("üèÅ Promise chain completed (success or failure)");
  });

console.log("This runs immediately while the Promise is pending!");

// Try running this several times to see both success and failure!`}
</InteractiveCodeBlock>

**Much better!** Notice how we can chain `.then()` calls and handle errors in one place with `.catch()`. But wait, it gets even better...

### Promise Chaining - Goodbye Callback Hell!

Remember our callback hell example? Let's fix it with Promises:

<InteractiveCodeBlock editable={true} language="javascript" >
{`// Let's rebuild our data fetching with Promises!

function fetchUserPromise(userId) {
  return new Promise(resolve => {
    setTimeout(() => {
      console.log(\`‚úÖ Fetched user \${userId}\`);
      resolve({ id: userId, name: \`User\${userId}\` });
    }, 300);
  });
}

function fetchUserPostsPromise(userId) {
  return new Promise(resolve => {
    setTimeout(() => {
      console.log(\`‚úÖ Fetched posts for user \${userId}\`);
      resolve([
        { id: 1, title: "My Promise Post", userId },
        { id: 2, title: "Promises Rock!", userId }
      ]);
    }, 400);
  });
}

function fetchPostCommentsPromise(postId) {
  return new Promise(resolve => {
    setTimeout(() => {
      console.log(\`‚úÖ Fetched comments for post \${postId}\`);
      resolve([
        { id: 1, text: "Love this Promise example!", postId },
        { id: 2, text: "So much cleaner than callbacks!", postId }
      ]);
    }, 200);
  });
}

// Look how clean this is! No more pyramid! üéâ
console.log("=== Promise Chain (No More Hell!) ===");

fetchUserPromise(1)
  .then(user => {
    console.log("Got user:", user.name);
    return fetchUserPostsPromise(user.id); // Return the next Promise
  })
  .then(posts => {
    console.log("Got posts:", posts.map(p => p.title));
    return fetchPostCommentsPromise(posts[0].id); // Chain continues...
  })
  .then(comments => {
    console.log("Got comments:", comments.map(c => c.text));
    console.log("üéâ All data loaded successfully!");
  })
  .catch(error => {
    console.error("üí• Any step could fail, caught here:", error);
  });

console.log("Beautiful! No more nested callbacks!");`}
</InteractiveCodeBlock>

**Isn't that gorgeous?** Clean, readable, and error handling in one place. But we can make it even better...

**Your turn!** Try adding a `.then()` step that filters the comments to only show ones with more than 10 characters.

### Promise Utilities - Power Tools! üõ†Ô∏è

JavaScript gives us some amazing Promise utilities. Let's explore them:

<InteractiveCodeBlock editable={true} language="javascript" >
{`// Let's explore the Promise utility methods!

// Simulate different API endpoints
function fetchUsers() {
  return new Promise(resolve => {
    setTimeout(() => {
      console.log("‚úÖ Users loaded");
      resolve(['Alice', 'Bob', 'Charlie']);
    }, 800);
  });
}

function fetchPosts() {
  return new Promise(resolve => {
    setTimeout(() => {
      console.log("‚úÖ Posts loaded");
      resolve(['Post 1', 'Post 2']);
    }, 600);
  });
}

function fetchComments() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      // Sometimes this fails!
      if (Math.random() > 0.3) {
        console.log("‚úÖ Comments loaded");
        resolve(['Comment 1', 'Comment 2', 'Comment 3']);
      } else {
        console.log("‚ùå Comments failed to load");
        reject(new Error("Comments service is down"));
      }
    }, 400);
  });
}

console.log("=== Promise.all() - Wait for ALL to complete ===");
console.log("Starting all requests simultaneously...");

Promise.all([fetchUsers(), fetchPosts(), fetchComments()])
  .then(([users, posts, comments]) => {
    console.log("üéâ ALL requests completed!");
    console.log("Users:", users.length);
    console.log("Posts:", posts.length);
    console.log("Comments:", comments.length);
  })
  .catch(error => {
    console.error("üí• If ANY fail, this runs:", error.message);
  });

// Wait a moment, then try Promise.allSettled
setTimeout(() => {
  console.log("\\n=== Promise.allSettled() - Wait for all to finish (success or fail) ===");
  
  Promise.allSettled([fetchUsers(), fetchPosts(), fetchComments()])
    .then(results => {
      console.log("üìä All settled! Here's what happened:");
      
      results.forEach((result, index) => {
        const names = ['Users', 'Posts', 'Comments'];
        if (result.status === 'fulfilled') {
          console.log(\`‚úÖ \${names[index]}: Success -\`, result.value);
        } else {
          console.log(\`‚ùå \${names[index]}: Failed -\`, result.reason.message);
        }
      });
    });
}, 2000);

// And let's try Promise.race
setTimeout(() => {
  console.log("\\n=== Promise.race() - First one wins! ===");
  
  const fastPromise = new Promise(resolve => {
    setTimeout(() => resolve("I'm fast! üèÉ‚Äç‚ôÇÔ∏è"), 100);
  });
  
  const slowPromise = new Promise(resolve => {
    setTimeout(() => resolve("I'm slow... üêå"), 1000);
  });
  
  Promise.race([fastPromise, slowPromise])
    .then(winner => {
      console.log("üèÜ Winner:", winner);
    });
}, 4000);`}
</InteractiveCodeBlock>

**Here's the key difference:**
- **Promise.all()**: All must succeed, or the whole thing fails
- **Promise.allSettled()**: Waits for all to finish, tells you what succeeded/failed  
- **Promise.race()**: First one to finish (success or failure) wins

**Challenge!** Create a timeout Promise that rejects after 2 seconds, then race it against our fetchComments() function. What happens?

## Async/Await - The Modern Way ‚ú®

Now for the game-changer! **Async/await makes asynchronous code look and feel like regular synchronous code.** It's like magic!

<InteractiveCodeBlock editable={true} language="javascript" >
{`// Let's see async/await in action!

// First, let's create some Promise-based functions
function fetchUserData(userId) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (userId > 0) {
        resolve({
          id: userId,
          name: \`User\${userId}\`,
          email: \`user\${userId}@example.com\`
        });
      } else {
        reject(new Error("Invalid user ID"));
      }
    }, 500);
  });
}

function fetchUserPreferences(userId) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve({
        theme: 'dark',
        notifications: true,
        language: 'en'
      });
    }, 300);
  });
}

// ‚ú® THE MAGIC HAPPENS HERE ‚ú®
async function getUserProfile(userId) {
  try {
    console.log(\`üîç Getting profile for user \${userId}...\`);
    
    // Look how clean this is! No .then() chains!
    const user = await fetchUserData(userId);
    console.log("‚úÖ Got user:", user.name);
    
    const preferences = await fetchUserPreferences(userId);
    console.log("‚úÖ Got preferences:", preferences.theme, "theme");
    
    // We can use regular JavaScript here!
    const profile = {
      ...user,
      preferences,
      fullProfile: true,
      loadedAt: new Date().toISOString()
    };
    
    console.log("üéâ Profile complete!");
    return profile;
    
  } catch (error) {
    console.error("üí• Profile failed:", error.message);
    throw error; // Re-throw if you want calling code to handle it
  }
}

// Using our async function
console.log("=== Async/Await Demo ===");

// Method 1: Using .then() (because async functions return Promises)
getUserProfile(42)
  .then(profile => {
    console.log("üìã Final profile:", profile);
  })
  .catch(error => {
    console.error("Caught in calling code:", error.message);
  });

// Method 2: Using await (but only inside another async function)
async function demo() {
  try {
    const profile = await getUserProfile(99);
    console.log("üìã Another profile:", profile.name);
  } catch (error) {
    console.error("Demo caught:", error.message);
  }
}

setTimeout(() => demo(), 1000);

console.log("This runs immediately while async operations are pending!");`}
</InteractiveCodeBlock>

**Wow!** Look how readable that is! The `await` keyword literally makes JavaScript wait for the Promise to resolve, but without blocking the thread.

**Key points:**
- `async` functions always return a Promise
- `await` can only be used inside `async` functions
- Use `try/catch` for error handling instead of `.catch()`

**Your experiment:** Try calling `getUserProfile(0)` to see the error handling in action!

### Async/Await vs Promises - The Comparison

Let me show you the same operation written both ways:

<InteractiveCodeBlock editable={true} language="javascript" >
{`// Let's compare Promise chains vs async/await for the SAME task

// Our helper functions
function fetchUser(id) {
  return new Promise(resolve => {
    setTimeout(() => resolve({ id, name: \`User\${id}\` }), 200);
  });
}

function fetchUserPosts(userId) {
  return new Promise(resolve => {
    setTimeout(() => resolve([
      { id: 1, title: "Post 1", userId },
      { id: 2, title: "Post 2", userId }
    ]), 300);
  });
}

function addPostMetadata(posts) {
  return new Promise(resolve => {
    setTimeout(() => {
      const enriched = posts.map(post => ({
        ...post,
        wordCount: post.title.length * 10, // Fake calculation
        readTime: Math.ceil(post.title.length / 10) + " min"
      }));
      resolve(enriched);
    }, 100);
  });
}

// üìú OLD WAY: Promise chains
console.log("=== Promise Chain Approach ===");

function getUserDataPromises(userId) {
  return fetchUser(userId)
    .then(user => {
      console.log("Promise: Got user", user.name);
      return fetchUserPosts(user.id)
        .then(posts => {
          console.log("Promise: Got", posts.length, "posts");
          return addPostMetadata(posts)
            .then(enrichedPosts => {
              console.log("Promise: Added metadata");
              return {
                user,
                posts: enrichedPosts,
                summary: \`\${user.name} has \${enrichedPosts.length} posts\`
              };
            });
        });
    });
}

// ‚ú® NEW WAY: Async/await
console.log("\\n=== Async/Await Approach ===");

async function getUserDataAsync(userId) {
  try {
    const user = await fetchUser(userId);
    console.log("Async: Got user", user.name);
    
    const posts = await fetchUserPosts(user.id);
    console.log("Async: Got", posts.length, "posts");
    
    const enrichedPosts = await addPostMetadata(posts);
    console.log("Async: Added metadata");
    
    return {
      user,
      posts: enrichedPosts,
      summary: \`\${user.name} has \${enrichedPosts.length} posts\`
    };
  } catch (error) {
    console.error("Async: Error occurred:", error);
    throw error;
  }
}

// Let's test both approaches
getUserDataPromises(1).then(result => {
  console.log("Promise result:", result.summary);
});

getUserDataAsync(2).then(result => {
  console.log("Async result:", result.summary);
});

// Which one is easier to read and understand?`}
</InteractiveCodeBlock>

**The async/await version reads like a story, doesn't it?** Much easier to understand and maintain!

### Parallel vs Sequential - Performance Matters! ‚ö°

Here's a crucial concept that trips up many developers:

<InteractiveCodeBlock editable={true} language="javascript" >
{`// Understanding parallel vs sequential execution

function slowTask(name, delay) {
  return new Promise(resolve => {
    setTimeout(() => {
      console.log(\`‚úÖ \${name} completed (took \${delay}ms)\`);
      resolve(\`Result from \${name}\`);
    }, delay);
  });
}

// ‚ùå SLOW: Sequential execution (one after another)
async function doTasksSequential() {
  console.log("üêå Starting sequential tasks...");
  const start = Date.now();
  
  const task1 = await slowTask("Task 1", 800);
  const task2 = await slowTask("Task 2", 600);
  const task3 = await slowTask("Task 3", 400);
  
  const elapsed = Date.now() - start;
  console.log(\`Sequential total time: \${elapsed}ms\`);
  // Total: ~1800ms (800 + 600 + 400)
  
  return [task1, task2, task3];
}

// ‚úÖ FAST: Parallel execution (all at once)
async function doTasksParallel() {
  console.log("üöÄ Starting parallel tasks...");
  const start = Date.now();
  
  // Start all tasks at the same time!
  const [task1, task2, task3] = await Promise.all([
    slowTask("Task A", 800),
    slowTask("Task B", 600),
    slowTask("Task C", 400)
  ]);
  
  const elapsed = Date.now() - start;
  console.log(\`Parallel total time: \${elapsed}ms\`);
  // Total: ~800ms (the longest task)
  
  return [task1, task2, task3];
}

// ‚öñÔ∏è MIXED: When tasks depend on each other
async function doTasksMixed() {
  console.log("üîÄ Starting mixed approach...");
  const start = Date.now();
  
  // First task must complete first
  const config = await slowTask("Load Config", 300);
  
  // These two can run in parallel since they only need config
  const [userData, settingsData] = await Promise.all([
    slowTask("Load User Data", 500),
    slowTask("Load Settings", 400)
  ]);
  
  const elapsed = Date.now() - start;
  console.log(\`Mixed total time: \${elapsed}ms\`);
  // Total: ~800ms (300 + max(500, 400))
  
  return [config, userData, settingsData];
}

// Let's race them!
console.log("‚è±Ô∏è Performance comparison starting...\\n");

// Run sequential first
doTasksSequential()
  .then(() => {
    console.log("\\n" + "=".repeat(50));
    
    // Then run parallel
    return doTasksParallel();
  })
  .then(() => {
    console.log("\\n" + "=".repeat(50));
    
    // Finally run mixed
    return doTasksMixed();
  })
  .then(() => {
    console.log("\\nüèÅ All done! See the time differences?");
  });

console.log("This runs while all the tasks are happening!");`}
</InteractiveCodeBlock>

**Mind blown?** The parallel version is more than twice as fast! This is crucial for real applications.

**Rule of thumb:**
- Use `await` when the next operation needs the result
- Use `Promise.all()` when operations can run simultaneously
- Mix both when some operations depend on others

**Challenge:** Create a function that loads user data (300ms), then loads their posts AND preferences in parallel (500ms and 400ms). What's the optimal total time?

## The Fetch API - Real-World HTTP Requests üåê

Now let's tackle real HTTP requests! The Fetch API is how modern JavaScript talks to servers.

<InteractiveCodeBlock editable={true} language="javascript" >
{`// Let's master the Fetch API!

// Basic GET request - the foundation
async function fetchUsers() {
  try {
    console.log("üåê Fetching users from API...");
    
    // Fetch returns a Promise!
    const response = await fetch('https://jsonplaceholder.typicode.com/users');
    
    // IMPORTANT: Check if the request was successful!
    if (!response.ok) {
      throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    
    // Convert response to JSON (this is also async!)
    const users = await response.json();
    
    console.log(\`‚úÖ Got \${users.length} users\`);
    console.log("First user:", users[0].name);
    
    return users;
    
  } catch (error) {
    console.error("üí• Fetch failed:", error.message);
    
    // You can return fallback data or re-throw
    return [];
  }
}

// POST request - sending data to server
async function createUser(userData) {
  try {
    console.log("üì§ Creating new user:", userData.name);
    
    const response = await fetch('https://jsonplaceholder.typicode.com/users', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        // You might also need authentication headers:
        // 'Authorization': 'Bearer your-token-here'
      },
      body: JSON.stringify(userData)
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(\`Failed to create user: \${errorData.message || response.statusText}\`);
    }
    
    const newUser = await response.json();
    console.log("‚úÖ User created with ID:", newUser.id);
    
    return newUser;
    
  } catch (error) {
    console.error("üí• Create user failed:", error.message);
    throw error; // Let calling code handle it
  }
}

// PUT request - updating existing data
async function updateUser(userId, updates) {
  try {
    console.log(\`üìù Updating user \${userId}...\`);
    
    const response = await fetch(\`https://jsonplaceholder.typicode.com/users/\${userId}\`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(updates)
    });
    
    if (!response.ok) {
      throw new Error(\`Update failed: \${response.status}\`);
    }
    
    const updatedUser = await response.json();
    console.log("‚úÖ User updated:", updatedUser.name);
    
    return updatedUser;
    
  } catch (error) {
    console.error("üí• Update failed:", error.message);
    throw error;
  }
}

// Let's test our API functions!
console.log("=== API Testing Begins ===");

async function demonstrateAPI() {
  try {
    // First, fetch existing users
    const users = await fetchUsers();
    
    // Create a new user
    const newUser = await createUser({
      name: 'John Doe',
      email: 'john@example.com',
      website: 'johndoe.com'
    });
    
    // Update the user we just created
    const updatedUser = await updateUser(newUser.id, {
      name: 'John Smith',
      email: 'john.smith@example.com'
    });
    
    console.log("üéâ All API operations completed successfully!");
    
  } catch (error) {
    console.error("üí• API demo failed:", error.message);
  }
}

// Run our demonstration
demonstrateAPI();

// This runs while the API calls are happening
console.log("API calls are running in the background...");`}
</InteractiveCodeBlock>

**Key insights:**
1. Always check `response.ok` - a 404 won't throw an error automatically!
2. `.json()` is async too - don't forget to await it
3. Set proper headers, especially `Content-Type` for JSON
4. Handle errors gracefully - network issues happen!

**Your mission:** Add a DELETE request function that removes a user. What status code should you check for success?

### Advanced Fetch Patterns - Production Ready! üöÄ

Let's build some robust, production-ready fetch utilities:

<InteractiveCodeBlock editable={true} language="javascript" >
{`// Advanced fetch patterns for real applications!

// Fetch with timeout - don't wait forever!
async function fetchWithTimeout(url, options = {}, timeout = 5000) {
  // Create an AbortController to cancel the request
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    return response;
    
  } catch (error) {
    clearTimeout(timeoutId);
    
    if (error.name === 'AbortError') {
      throw new Error(\`Request timeout after \${timeout}ms\`);
    }
    
    throw error;
  }
}

// Fetch with retry logic - handle flaky networks!
async function fetchWithRetry(url, options = {}, maxRetries = 3) {
  let lastError;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(\`üîÑ Attempt \${attempt} for \${url}\`);
      
      const response = await fetchWithTimeout(url, options, 3000);
      
      if (response.ok) {
        console.log(\`‚úÖ Success on attempt \${attempt}\`);
        return response;
      }
      
      // Server errors might be temporary, retry them
      if (response.status >= 500) {
        throw new Error(\`Server error: \${response.status}\`);
      }
      
      // Client errors (like 404) shouldn't be retried
      throw new Error(\`Client error: \${response.status}\`);
      
    } catch (error) {
      lastError = error;
      
      console.log(\`‚ùå Attempt \${attempt} failed: \${error.message}\`);
      
      // Don't retry on the last attempt
      if (attempt === maxRetries) {
        break;
      }
      
      // Exponential backoff - wait longer each time
      const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);
      console.log(\`‚è≥ Waiting \${delay}ms before retry...\`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  throw new Error(\`Failed after \${maxRetries} attempts: \${lastError.message}\`);
}

// Smart API client with caching
class SmartAPIClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.cache = new Map();
    this.pendingRequests = new Map(); // Prevent duplicate requests
  }
  
  // Generate cache key from URL and options
  getCacheKey(url, options) {
    return JSON.stringify({ url, method: options.method || 'GET' });
  }
  
  async request(endpoint, options = {}) {
    const fullURL = this.baseURL + endpoint;
    const cacheKey = this.getCacheKey(fullURL, options);
    
    // For GET requests, check cache first
    if ((!options.method || options.method === 'GET') && this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey);
      
      // Check if cache is still fresh (5 minutes)
      if (Date.now() - cached.timestamp < 5 * 60 * 1000) {
        console.log("üìã Using cached data for", endpoint);
        return cached.data;
      }
      
      console.log("‚è∞ Cache expired for", endpoint);
      this.cache.delete(cacheKey);
    }
    
    // Prevent duplicate requests
    if (this.pendingRequests.has(cacheKey)) {
      console.log("üîÑ Request already in progress, waiting...");
      return this.pendingRequests.get(cacheKey);
    }
    
    // Make the actual request
    const requestPromise = this.makeRequest(fullURL, options);
    this.pendingRequests.set(cacheKey, requestPromise);
    
    try {
      const result = await requestPromise;
      
      // Cache GET requests
      if (!options.method || options.method === 'GET') {
        this.cache.set(cacheKey, {
          data: result,
          timestamp: Date.now()
        });
      }
      
      return result;
      
    } finally {
      this.pendingRequests.delete(cacheKey);
    }
  }
  
  async makeRequest(url, options) {
    console.log(\`üåê Making request to \${url}\`);
    
    const response = await fetchWithRetry(url, {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      ...options
    });
    
    if (!response.ok) {
      throw new Error(\`HTTP \${response.status}: \${response.statusText}\`);
    }
    
    return response.json();
  }
  
  // Convenience methods
  async get(endpoint) {
    return this.request(endpoint, { method: 'GET' });
  }
  
  async post(endpoint, data) {
    return this.request(endpoint, {
      method: 'POST',
      body: JSON.stringify(data)
    });
  }
  
  // Clear cache when data changes
  invalidateCache() {
    console.log("üßπ Cache cleared");
    this.cache.clear();
  }
}

// Let's test our advanced API client!
const api = new SmartAPIClient('https://jsonplaceholder.typicode.com');

async function demonstrateAdvancedAPI() {
  try {
    console.log("=== Advanced API Demo ===");
    
    // First request - will hit the network
    const users1 = await api.get('/users');
    console.log("First call - got", users1.length, "users");
    
    // Second request - should use cache
    const users2 = await api.get('/users');
    console.log("Second call - got", users2.length, "users");
    
    // Create a new user - this will clear cache
    const newUser = await api.post('/users', {
      name: 'Cache Test User',
      email: 'cache@test.com'
    });
    console.log("Created user:", newUser.name);
    
    api.invalidateCache();
    
    // This should hit network again
    const users3 = await api.get('/users');
    console.log("After cache clear - got", users3.length, "users");
    
  } catch (error) {
    console.error("üí• Advanced API demo failed:", error.message);
  }
}

demonstrateAdvancedAPI();

console.log("Advanced fetch patterns are running...");`}
</InteractiveCodeBlock>

**This is production-grade stuff!** Features included:
- **Timeout protection** - don't hang forever
- **Retry with exponential backoff** - handle flaky networks  
- **Smart caching** - avoid unnecessary requests
- **Request deduplication** - prevent duplicate requests
- **Proper error handling** - distinguish client vs server errors

**Challenge:** Add a `put()` method to the SmartAPIClient. Should PUT requests be cached?

## Error Handling - Making Your Code Bulletproof üõ°Ô∏è

Let's dive deep into robust error handling patterns:

<InteractiveCodeBlock editable={true} language="javascript" >
{`// Advanced error handling patterns

// Custom error classes for different scenarios
class NetworkError extends Error {
  constructor(message, status = null) {
    super(message);
    this.name = 'NetworkError';
    this.status = status;
    this.timestamp = new Date().toISOString();
  }
}

class ValidationError extends Error {
  constructor(message, field = null) {
    super(message);
    this.name = 'ValidationError';
    this.field = field;
  }
}

class TimeoutError extends Error {
  constructor(message, timeoutMs) {
    super(message);
    this.name = 'TimeoutError';
    this.timeoutMs = timeoutMs;
  }
}

// Robust data fetcher with comprehensive error handling
async function robustDataFetcher(userId) {
  // Input validation first!
  if (!userId || typeof userId !== 'number' || userId <= 0) {
    throw new ValidationError('User ID must be a positive number', 'userId');
  }
  
  console.log(\`üîç Fetching data for user \${userId}\`);
  
  try {
    // Main data fetch with timeout
    const userPromise = fetchUserWithTimeout(userId);
    
    // Optional data fetches with fallbacks
    const postsPromise = fetchUserPosts(userId).catch(error => {
      console.warn(\`‚ö†Ô∏è Posts failed for user \${userId}:, error.message\`);
      return []; // Fallback to empty array
    });
    
    const prefsPromise = fetchUserPreferences(userId).catch(error => {
      console.warn(\`‚ö†Ô∏è Preferences failed for user \${userId}:, error.message\`);
      return { theme: 'light', notifications: true }; // Default preferences
    });
    
    // Wait for main data (required) and optional data (with fallbacks)
    const [user, posts, preferences] = await Promise.all([
      userPromise,
      postsPromise,
      prefsPromise
    ]);
    
    // Additional validation
    if (!user || !user.id) {
      throw new ValidationError('Invalid user data received');
    }
    
    console.log(\`‚úÖ Successfully loaded data for \${user.name}\`);
    
    return {
      user,
      posts,
      preferences,
      metadata: {
        hasCompletePosts: posts.length > 0,
        hasCustomPrefs: preferences.theme !== 'light',
        loadedAt: new Date().toISOString()
      }
    };
    
  } catch (error) {
    // Enhanced error logging
    console.error("üí• Error in robustDataFetcher:", {
      userId,
      errorName: error.name,
      errorMessage: error.message,
      stack: error.stack?.split('\\n')[0] // First line of stack trace
    });
    
    // Transform errors for better handling upstream
    if (error.name === 'AbortError') {
      throw new TimeoutError("Request timed out while fetching user data", 5000);
    }
    
    if (error.status === 404) {
      throw new ValidationError(\`User \${userId} not found\`);
    }
    
    if (error.status >= 500) {
      throw new NetworkError("Server error occurred", error.status);
    }
    
    // Re-throw validation errors as-is
    if (error instanceof ValidationError) {
      throw error;
    }
    
    // Wrap unknown errors
    throw new NetworkError(\`Unexpected error: \${error.message}\`);
  }
}

// Helper functions for the demo
async function fetchUserWithTimeout(userId) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 3000);
  
  try {
    // Simulate different scenarios
    const scenarios = [
      () => ({ id: userId, name: \`User\${userId}\`, email: \`user\${userId}@example.com\` }),
      () => { throw new Error("User not found"); },
      () => { throw Object.assign(new Error("Server error"), { status: 500 }); }
    ];
    
    const scenario = scenarios[Math.floor(Math.random() * scenarios.length)];
    
    await new Promise(resolve => setTimeout(resolve, 500)); // Simulate delay
    clearTimeout(timeoutId);
    
    return scenario();
    
  } catch (error) {
    clearTimeout(timeoutId);
    throw error;
  }
}

async function fetchUserPosts(userId) {
  await new Promise(resolve => setTimeout(resolve, 300));
  
  if (Math.random() > 0.7) {
    throw new Error("Posts service unavailable");
  }
  
  return [
    { id: 1, title: "My first post", userId },
    { id: 2, title: "Another post", userId }
  ];
}

async function fetchUserPreferences(userId) {
  await new Promise(resolve => setTimeout(resolve, 200));
  
  if (Math.random() > 0.8) {
    throw new Error("Preferences service down");
  }
  
  return { theme: 'dark', notifications: false };
}

// Demonstration with specific error handling
async function demonstrateErrorHandling() {
  const userIds = [1, -1, 2, 999];
  
  for (const userId of userIds) {
    try {
      console.log(\`\\n=== Processing User \${userId} ===\`);
      
      const result = await robustDataFetcher(userId);
      console.log("üéâ Success:", result.user.name);
      console.log("üìä Metadata:", result.metadata);
      
    } catch (error) {
      // Handle different error types appropriately
      if (error instanceof ValidationError) {
        console.error("üî¥ Validation Error:", error.message);
        if (error.field) {
          console.error("   Field:", error.field);
        }
      } else if (error instanceof NetworkError) {
        console.error("üåê Network Error:", error.message);
        if (error.status) {
          console.error("   Status:", error.status);
        }
      } else if (error instanceof TimeoutError) {
        console.error("‚è∞ Timeout Error:", error.message);
        console.error("   Timeout was:", error.timeoutMs + "ms");
      } else {
        console.error("‚ùì Unknown Error:", error.message);
      }
    }
  }
}

// Let's see error handling in action!
console.log("=== Error Handling Demonstration ===");
demonstrateErrorHandling();

console.log("\\nError handling demo is running...");`}
</InteractiveCodeBlock>

**This is professional-grade error handling!** Notice how we:

1. **Validate inputs early** - catch problems before they cause issues
2. **Use specific error types** - makes handling much cleaner
3. **Provide fallbacks** - app keeps working even when some things fail
4. **Log useful information** - helps with debugging
5. **Transform errors** - give calling code what it expects

**Your challenge:** Add a `RetryableError` class and modify the fetcher to automatically retry certain types of failures.

## Real-World Patterns - What You'll Actually Build üåü

Let's create some patterns you'll use in real applications:

<InteractiveCodeBlock editable={true} language="javascript" >
{`// Real-world async patterns you'll actually use!

// Pattern 1: Debounced Search (like Google's search suggestions)
class DebouncedSearch {
  constructor(searchFunction, delay = 300) {
    this.search = searchFunction;
    this.delay = delay;
    this.timeoutId = null;
    this.abortController = null;
  }
  
  async performSearch(query) {
    // Cancel any pending search
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
    
    // Cancel any in-flight request
    if (this.abortController) {
      this.abortController.abort();
    }
    
    // Return immediately for empty queries
    if (!query.trim()) {
      return [];
    }
    
    return new Promise((resolve, reject) => {
      this.timeoutId = setTimeout(async () => {
        try {
          this.abortController = new AbortController();
          const results = await this.search(query, this.abortController.signal);
          resolve(results);
        } catch (error) {
          if (error.name !== 'AbortError') {
            reject(error);
          }
          // Ignore abort errors - they're expected
        }
      }, this.delay);
    });
  }
}

// Simulate a search API
async function searchAPI(query, signal) {
  console.log(\`üîç Searching for: "\${query}"\`);
  
  // Simulate network delay
  await new Promise((resolve, reject) => {
    const timeout = setTimeout(resolve, Math.random() * 800 + 200);
    
    signal?.addEventListener('abort', () => {
      clearTimeout(timeout);
      reject(new Error('AbortError'));
    });
  });
  
  // Simulate search results
  const mockResults = [
    \`Result 1 for "\${query}"\`,
    \`Result 2 for "\${query}"\`,
    \`Result 3 for "\${query}"\`
  ];
  
  console.log(\`‚úÖ Search completed for: "\${query}"\`);
  return mockResults;
}

// Pattern 2: Task Queue with Concurrency Control
class TaskQueue {
  constructor(concurrency = 3) {
    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }
  
  async add(taskFunction, priority = 0) {
    return new Promise((resolve, reject) => {
      const task = {
        function: taskFunction,
        resolve,
        reject,
        priority
      };
      
      // Insert based on priority (higher priority first)
      const insertIndex = this.queue.findIndex(t => t.priority < priority);
      if (insertIndex === -1) {
        this.queue.push(task);
      } else {
        this.queue.splice(insertIndex, 0, task);
      }
      
      this.processNext();
    });
  }
  
  async processNext() {
    if (this.running >= this.concurrency || this.queue.length === 0) {
      return;
    }
    
    this.running++;
    const task = this.queue.shift();
    
    try {
      const result = await task.function();
      task.resolve(result);
    } catch (error) {
      task.reject(error);
    } finally {
      this.running--;
      this.processNext(); // Process next task
    }
  }
  
  get status() {
    return {
      running: this.running,
      queued: this.queue.length,
      total: this.running + this.queue.length
    };
  }
}

// Pattern 3: Data Pipeline with Progress Tracking
class DataPipeline {
  constructor(name) {
    this.name = name;
    this.steps = [];
    this.onProgress = null;
  }
  
  addStep(name, asyncFunction) {
    this.steps.push({ name, function: asyncFunction });
    return this; // Chainable
  }
  
  onProgressUpdate(callback) {
    this.onProgress = callback;
    return this; // Chainable
  }
  
  async execute(initialData) {
    let data = initialData;
    const results = [];
    
    console.log(\`üöÄ Starting pipeline: \${this.name}\`);
    
    for (let i = 0; i < this.steps.length; i++) {
      const step = this.steps[i];
      const progress = ((i + 1) / this.steps.length) * 100;
      
      try {
        console.log(\`‚öôÔ∏è  Step \${i + 1}/\${this.steps.length}: \${step.name}\`);
        
        if (this.onProgress) {
          this.onProgress(progress, step.name);
        }
        
        const stepResult = await step.function(data);
        data = stepResult;
        
        results.push({
          step: step.name,
          success: true,
          duration: \`Completed\`
        });
        
      } catch (error) {
        console.error(\`‚ùå Step failed: \${step.name}\`, error.message);
        
        results.push({
          step: step.name,
          success: false,
          error: error.message
        });
        
        throw new Error(\`Pipeline failed at step: \${step.name}\`);
      }
    }
    
    console.log(\`‚úÖ Pipeline completed: \${this.name}\`);
    return { data, results };
  }
}

// Let's demonstrate these patterns!
console.log("=== Real-World Patterns Demo ===");

// Demo 1: Debounced Search
const debouncedSearch = new DebouncedSearch(searchAPI, 500);

async function simulateUserTyping() {
  console.log("\\n--- Simulating User Typing ---");
  
  const queries = ['j', 'ja', 'jav', 'java', 'javascript'];
  
  for (const query of queries) {
    console.log(\`User typed: "\${query}"\`);
    
    // Don't await - simulate rapid typing
    debouncedSearch.performSearch(query)
      .then(results => {
        console.log(\`üìã Results for "\${query}":, results.length\`);
      })
      .catch(error => {
        console.error(\`Search error for "\${query}":, error.message\`);
      });
    
    await new Promise(resolve => setTimeout(resolve, 200)); // Typing speed
  }
}

// Demo 2: Task Queue
async function demonstrateTaskQueue() {
  console.log("\\n--- Task Queue Demo ---");
  
  const queue = new TaskQueue(2); // Max 2 concurrent tasks
  
  // Create some tasks with different priorities and durations
  const tasks = [
    { name: 'Low Priority Task', delay: 1000, priority: 1 },
    { name: 'High Priority Task', delay: 500, priority: 10 },
    { name: 'Normal Task 1', delay: 800, priority: 5 },
    { name: 'Critical Task', delay: 300, priority: 20 },
    { name: 'Normal Task 2', delay: 600, priority: 5 }
  ];
  
  // Add all tasks to queue
  const promises = tasks.map(task => 
    queue.add(async () => {
      console.log(\`üî® Starting: \${task.name}\`);
      await new Promise(resolve => setTimeout(resolve, task.delay));
      console.log(\`‚úÖ Finished: \${task.name}\`);
      return \`Result from \${task.name}\`;
    }, task.priority)
  );
  
  // Monitor queue status
  const statusInterval = setInterval(() => {
    const status = queue.status;
    if (status.total > 0) {
      console.log(\`üìä Queue: \${status.running} running, \${status.queued} queued\`);
    } else {
      clearInterval(statusInterval);
    }
  }, 300);
  
  // Wait for all tasks
  const results = await Promise.all(promises);
  console.log("üéâ All tasks completed");
}

// Demo 3: Data Pipeline
async function demonstratePipeline() {
  console.log("\\n--- Data Pipeline Demo ---");
  
  const pipeline = new DataPipeline("User Onboarding")
    .addStep("Validate User Data", async (data) => {
      await new Promise(resolve => setTimeout(resolve, 300));
      if (!data.email) throw new Error("Email required");
      return { ...data, validated: true };
    })
    .addStep("Create Account", async (data) => {
      await new Promise(resolve => setTimeout(resolve, 500));
      return { ...data, userId: Math.floor(Math.random() * 1000) };
    })
    .addStep("Send Welcome Email", async (data) => {
      await new Promise(resolve => setTimeout(resolve, 400));
      return { ...data, emailSent: true };
    })
    .addStep("Setup Default Preferences", async (data) => {
      await new Promise(resolve => setTimeout(resolve, 200));
      return { ...data, preferences: { theme: 'light', notifications: true } };
    })
    .onProgressUpdate((progress, stepName) => {
      console.log(\`üìà Progress: \${progress.toFixed(1)}% - \${stepName}\`);
    });
  
  try {
    const result = await pipeline.execute({
      name: "John Doe",
      email: "john@example.com"
    });
    
    console.log("üéâ Pipeline success! User ID:", result.data.userId);
    
  } catch (error) {
    console.error("üí• Pipeline failed:", error.message);
  }
}

// Run all demonstrations
simulateUserTyping()
  .then(() => demonstrateTaskQueue())
  .then(() => demonstratePipeline())
  .then(() => {
    console.log("\\nüèÅ All real-world patterns demonstrated!");
  });

console.log("Real-world patterns are running...");`}
</InteractiveCodeBlock>

**These patterns are gold!** You'll use variations of these in almost every real application:

1. **Debounced Search** - Prevents excessive API calls while typing
2. **Task Queue** - Controls resource usage and handles priorities  
3. **Data Pipeline** - Processes complex workflows with progress tracking

**Your mission:** Enhance the TaskQueue to support task cancellation. Add a `cancel(taskId)` method!

## Performance Optimization - Making It Lightning Fast ‚ö°

Let's explore some advanced performance patterns:

<InteractiveCodeBlock editable={true} language="javascript" >
{`// Advanced performance optimization techniques!

// Pattern 1: Request Deduplication
class RequestDeduplicator {
  constructor() {
    this.pendingRequests = new Map();
  }
  
  async fetch(url, options = {}) {
    const key = this.createKey(url, options);
    
    // If request is already in flight, return the same Promise
    if (this.pendingRequests.has(key)) {
      console.log(\`üîÑ Deduplicating request to \${url}\`);
      return this.pendingRequests.get(key);
    }
    
    // Create new request
    console.log(\`üåê New request to \${url}\`);
    const promise = fetch(url, options)
      .then(response => response.json())
      .finally(() => {
        // Clean up when done
        this.pendingRequests.delete(key);
      });
    
    this.pendingRequests.set(key, promise);
    return promise;
  }
  
  createKey(url, options) {
    return JSON.stringify({ 
      url, 
      method: options.method || 'GET',
      body: options.body 
    });
  }
}

// Pattern 2: Preloading and Prefetching
class ResourcePreloader {
  constructor() {
    this.cache = new Map();
    this.preloadPromises = new Map();
  }
  
  // Preload critical resources immediately
  preloadCritical(...urls) {
    console.log("üöÄ Preloading critical resources...");
    
    const promises = urls.map(url => this.preload(url, 'critical'));
    return Promise.all(promises);
  }
  
  // Prefetch likely-needed resources in the background
  prefetchLikelyNeeded(...urls) {
    console.log("üí≠ Prefetching likely-needed resources...");
    
    urls.forEach(url => {
      // Fire and forget - don't wait for these
      this.preload(url, 'prefetch').catch(() => {
        // Silently fail for prefetches
      });
    });
  }
  
  async preload(url, type = 'normal') {
    if (this.cache.has(url)) {
      console.log(\`üìã Already cached: \${url}\`);
      return this.cache.get(url);
    }
    
    if (this.preloadPromises.has(url)) {
      console.log(\`‚è≥ Already preloading: \${url}\`);
      return this.preloadPromises.get(url);
    }
    
    const promise = fetch(url)
      .then(response => response.json())
      .then(data => {
        console.log(\`‚úÖ Preloaded (\${type}): \${url}\`);
        this.cache.set(url, data);
        return data;
      })
      .finally(() => {
        this.preloadPromises.delete(url);
      });
    
    this.preloadPromises.set(url, promise);
    return promise;
  }
  
  // Get resource - use cache if available
  async getResource(url) {
    if (this.cache.has(url)) {
      console.log(\`‚ö° Cache hit: \${url}\`);
      return this.cache.get(url);
    }
    
    console.log(\`üåê Cache miss, fetching: \${url}\`);
    return this.preload(url);
  }
}

// Pattern 3: Batch Processing with Backpressure
class BatchProcessor {
  constructor(processFn, options = {}) {
    this.processFn = processFn;
    this.batchSize = options.batchSize || 10;
    this.delay = options.delay || 100;
    this.maxConcurrent = options.maxConcurrent || 3;
    
    this.queue = [];
    this.processing = false;
    this.activeJobs = 0;
  }
  
  async add(item) {
    return new Promise((resolve, reject) => {
      this.queue.push({ item, resolve, reject });
      
      if (!this.processing) {
        this.startProcessing();
      }
    });
  }
  
  async startProcessing() {
    if (this.processing) return;
    
    this.processing = true;
    console.log("üèÉ Batch processor started");
    
    while (this.queue.length > 0) {
      // Wait if we're at max concurrent jobs
      while (this.activeJobs >= this.maxConcurrent) {
        await new Promise(resolve => setTimeout(resolve, 50));
      }
      
      // Get next batch
      const batch = this.queue.splice(0, this.batchSize);
      if (batch.length === 0) break;
      
      // Process batch concurrently
      this.processBatch(batch);
      
      // Small delay between batch starts
      if (this.queue.length > 0) {
        await new Promise(resolve => setTimeout(resolve, this.delay));
      }
    }
    
    // Wait for all jobs to complete
    while (this.activeJobs > 0) {
      await new Promise(resolve => setTimeout(resolve, 50));
    }
    
    this.processing = false;
    console.log("‚úÖ Batch processor completed");
  }
  
  async processBatch(batch) {
    this.activeJobs++;
    
    try {
      console.log(\`üì¶ Processing batch of \${batch.length} items\`);
      
      const items = batch.map(b => b.item);
      const results = await this.processFn(items);
      
      // Resolve individual promises
      batch.forEach((batchItem, index) => {
        batchItem.resolve(results[index]);
      });
      
    } catch (error) {
      // Reject all items in this batch
      batch.forEach(batchItem => {
        batchItem.reject(error);
      });
    } finally {
      this.activeJobs--;
    }
  }
}

// Let's demonstrate these optimizations!
console.log("=== Performance Optimization Demo ===");

// Demo 1: Request Deduplication
const deduplicator = new RequestDeduplicator();

async function demonstrateDeduplication() {
  console.log("\\n--- Request Deduplication ---");
  
  const url = 'https://jsonplaceholder.typicode.com/users/1';
  
  // Make multiple simultaneous requests - only one should actually be made
  const promises = [
    deduplicator.fetch(url),
    deduplicator.fetch(url),
    deduplicator.fetch(url)
  ];
  
  const results = await Promise.all(promises);
  console.log("üìä All got same data:", results[0].id === results[1].id);
}

// Demo 2: Preloading and Prefetching  
async function demonstratePreloading() {
  console.log("\\n--- Preloading Demo ---");
  
  const preloader = new ResourcePreloader();
  
  // Preload critical resources
  await preloader.preloadCritical(
    'https://jsonplaceholder.typicode.com/users/1'
  );
  
  // Prefetch likely-needed resources
  preloader.prefetchLikelyNeeded(
    'https://jsonplaceholder.typicode.com/users/2',
    'https://jsonplaceholder.typicode.com/users/3'
  );
  
  // Later, when we need the resource...
  console.log("üìö Getting user 1 (should be cached):");
  const user1 = await preloader.getResource('https://jsonplaceholder.typicode.com/users/1');
  
  console.log("üìö Getting user 2 (might be prefetched):");
  const user2 = await preloader.getResource('https://jsonplaceholder.typicode.com/users/2');
  
  console.log(\`Got users: \${user1.name} and \${user2.name}\`);
}

// Demo 3: Batch Processing
async function demonstrateBatchProcessing() {
  console.log("\\n--- Batch Processing ---");
  
  // Simulate a batch processing function
  async function processImageBatch(imageIds) {
    console.log(\`üñºÔ∏è  Processing \${imageIds.length} images: \${imageIds.join(', ')}\`);
    
    // Simulate processing time
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Return processed results
    return imageIds.map(id => \`processed-\${id}\`);
  }
  
  const processor = new BatchProcessor(processImageBatch, {
    batchSize: 3,
    delay: 200,
    maxConcurrent: 2
  });
  
  // Add many items to process
  const imageIds = Array.from({ length: 15 }, (_, i) => \`img-\${i + 1}\`);
  
  console.log(\`Adding \${imageIds.length} images to batch processor...\`);
  
  const promises = imageIds.map(id => processor.add(id));
  
  // Wait for all to complete
  const results = await Promise.all(promises);
  console.log(\`‚úÖ Processed \${results.length} images\`);
  console.log("First few results:", results.slice(0, 3));
}

// Performance comparison
async function performanceComparison() {
  console.log("\\n--- Performance Comparison ---");
  
  // Simulate slow API calls
  const slowAPI = (id) => new Promise(resolve => {
    setTimeout(() => resolve(\`data-\${id}\`), 200);
  });
  
  console.log("‚è±Ô∏è Sequential processing (slow):");
  const start1 = Date.now();
  const sequential = [];
  for (let i = 1; i <= 5; i++) {
    sequential.push(await slowAPI(i));
  }
  const time1 = Date.now() - start1;
  console.log(\`Sequential: \${time1}ms for \${sequential.length} items\`);
  
  console.log("‚ö° Parallel processing (fast):");
  const start2 = Date.now();
  const parallel = await Promise.all([
    slowAPI(6), slowAPI(7), slowAPI(8), slowAPI(9), slowAPI(10)
  ]);
  const time2 = Date.now() - start2;
  console.log(\`Parallel: \${time2}ms for \${parallel.length} items\`);
  
  console.log(\`üöÄ Speedup: \${(time1 / time2).toFixed(1)}x faster!\`);
}

// Run all demonstrations
demonstrateDeduplication()
  .then(() => demonstratePreloading())
  .then(() => demonstrateBatchProcessing())
  .then(() => performanceComparison())
  .then(() => {
    console.log("\\nüèÅ Performance optimization demo completed!");
  });

console.log("Performance patterns are running...");`}
</InteractiveCodeBlock>

**These optimizations can dramatically improve your app's performance!**

Key takeaways:
- **Deduplication** prevents wasted network requests
- **Preloading** makes the app feel instant
- **Batch processing** handles large datasets efficiently
- **Parallel > Sequential** for independent operations

**Your final challenge:** Combine all three patterns into a smart data manager that preloads, deduplicates, and batch processes user actions!

## What You've Mastered Today üèÜ

Congratulations! You've just become an async JavaScript expert. Here's what you can now do confidently:

### ‚úÖ **Foundation Skills**
- Understand the event loop and why async programming exists
- Write clean code with Promises instead of callback hell
- Master async/await for readable asynchronous code
- Handle errors properly with try/catch and custom error types

### ‚úÖ **Advanced Patterns** 
- Build robust HTTP clients with retry logic and timeouts
- Implement performance optimizations like request deduplication
- Create real-world patterns like debounced search and task queues
- Handle complex data pipelines with progress tracking

### ‚úÖ **Professional Techniques**
- Design bulletproof error handling strategies
- Optimize performance with preloading and caching
- Control concurrency and prevent resource exhaustion
- Build production-ready async applications

### ‚úÖ **Real-World Applications**
- Fetch data from APIs reliably
- Create responsive user interfaces
- Handle complex async workflows
- Build scalable, performant applications

## Common Pitfalls to Avoid üö®

1. **Forgetting to handle errors** - Always use try/catch with async/await
2. **Sequential when you could be parallel** - Use Promise.all() when operations are independent
3. **Not setting timeouts** - Network requests can hang forever
4. **Memory leaks with promises** - Clean up properly, especially with abort controllers
5. **Blocking the event loop** - Break up large operations into smaller chunks

## Your Next Steps üöÄ

You've mastered async JavaScript! Here's what to explore next:

1. **Advanced JavaScript Patterns** - Closures, modules, and design patterns
2. **Modern Framework Usage** - React, Vue, or Angular with async patterns
3. **Backend Development** - Node.js, Express, and async server programming
4. **Performance Monitoring** - Learn to measure and optimize async operations

Remember: **Async programming is not just about making things work - it's about making them work beautifully, efficiently, and reliably.** You now have the tools to build amazing user experiences!

**Keep practicing, and happy coding!** üéâ

## Quiz Time! üß†

You've mastered asynchronous JavaScript! Time to test your knowledge with these advanced async patterns.

## What's Next?

Congratulations! üéâ You now have deep expertise in asynchronous JavaScript. Coming up next:

- **DOM Manipulation & Events** - Making web pages interactive
- **JavaScript Modules & Build Tools** - Modern JavaScript development  
- **Testing JavaScript Applications** - Writing reliable, maintainable code

You're well on your way to becoming a JavaScript expert! üöÄ