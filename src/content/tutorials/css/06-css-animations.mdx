---
title: "CSS Animations"
description: "Master CSS keyframe animations to create engaging and interactive user experiences with smooth motion graphics."
category: "css"
subcategory: "animations"
order: 6
premium: false
estimatedTime: 80
quizQuestions: 20
---

# CSS Animations: Bringing Life to Your Websites

Welcome to CSS Animations! In this tutorial, you'll learn how to create smooth, engaging animations using CSS keyframes. We'll cover everything from basic animations to complex sequences that bring your web pages to life.

## üéØ What You'll Master

By the end of this tutorial, you'll be able to:
- Create keyframe animations with multiple stages
- Control animation timing, direction, and repetition
- Build interactive hover effects and loading animations  
- Optimize animations for smooth performance
- Combine multiple animations for complex effects

## Understanding CSS Animations vs Transitions

**Transitions** animate between two states (A ‚Üí B)
**Animations** can have multiple keyframes and complex sequences (A ‚Üí B ‚Üí C ‚Üí D)

### Essential Animation Properties Explained

- **`@keyframes`** - Define the animation sequence with multiple steps
- **`animation-name`** - Connect your element to a specific keyframe animation
- **`animation-duration`** - Controls how long the entire animation takes
- **`animation-timing-function`** - The acceleration curve (ease, linear, etc.)
- **`animation-delay`** - Wait time before animation starts
- **`animation-iteration-count`** - How many times to repeat (1, 3, infinite)
- **`animation-direction`** - Play forward, reverse, or alternating
- **`animation-fill-mode`** - What styles apply before/after animation
- **`animation-play-state`** - Pause or resume animations

## Creating Your First Animation: Fade-In Effect

Let's start with a fundamental animation - making elements appear smoothly:

<SeparatedEditorPreview 
  title="üé¨ Basic Fade-In Animation"
  mission="Create a smooth fade-in effect for a welcome message"
  instructions="Study how @keyframes define animation steps, then try changing the duration and timing function"
initialHtml={`<div class="welcome-message">
  Welcome to CSS Animations!
</div>`}
initialCss={`/* STEP 1: Define the animation sequence */
@keyframes fadeIn {
  from {
    opacity: 0;    /* Start: completely transparent */
  }
  to {
    opacity: 1;    /* End: fully visible */
  }
}

/* STEP 2: Apply the animation to an element */
.welcome-message {
  /* Basic styling */
  font-size: 24px;
  text-align: center;
  padding: 20px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border-radius: 8px;
  
  /* Animation properties */
  animation-name: fadeIn;              /* Which keyframes to use */
  animation-duration: 2s;              /* How long it takes */
  animation-timing-function: ease-in-out;  /* Speed curve */
}`}/>

### üìö How This Animation Works:

1. **`@keyframes fadeIn`** - Creates a named animation sequence called "fadeIn"
2. **`from` and `to`** - Simple way to define start and end states
3. **`opacity: 0 ‚Üí 1`** - Element fades from invisible to visible
4. **`animation-name: fadeIn`** - Connects the element to our keyframes
5. **`animation-duration: 2s`** - Takes 2 seconds to complete
6. **`ease-in-out`** - Starts slow, speeds up, then slows down (most natural)

### üéÆ Try This Challenge:
1. In **`.welcome-message`**, **change the duration** from `animation-duration: 2s;` to `0.5s` - notice how it becomes snappy
2. In **`.welcome-message`**, **change the timing** from `ease-in-out` to `linear` - see how it becomes mechanical  
3. In **`.welcome-message`**, **add a delay** with `animation-delay: 1s;` after the timing function - creates suspense
4. In **`@keyframes fadeIn`** at `from`, **try different start values** like `opacity: 0.3;` instead of `opacity: 0;`


## Advanced Keyframes: Multiple Animation Steps

Move beyond simple `from/to` animations by using percentages to create complex sequences:

<SeparatedEditorPreview 
  title="üåà Multi-Step Rainbow Animation"
  mission="Create a rainbow color-changing animation with precise timing"
  instructions="Study how percentages control timing, then try adding your own color stops"
initialHtml={`<div class="rainbow-box">
  Rainbow Animation
</div>`}
initialCss={`/* Using percentages for precise control over timing */
@keyframes rainbow {
  0% { background-color: red; }      /* Animation start */
  16.66% { background-color: orange; } /* 16.66% of the way through */
  33.33% { background-color: yellow; } /* 33.33% of the way through */
  50% { background-color: green; }     /* Halfway point */
  66.66% { background-color: blue; }   /* 66.66% of the way through */
  83.33% { background-color: indigo; } /* 83.33% of the way through */
  100% { background-color: violet; }   /* Animation end */
}

.rainbow-box {
  /* Layout and styling */
  width: 200px;
  height: 100px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: bold;
  border-radius: 8px;
  margin: 20px auto;
  
  /* Animation shorthand: name duration iteration timing */
  animation: rainbow 3s infinite linear;
  /* Breakdown:
     - rainbow: use the rainbow keyframes
     - 3s: each cycle takes 3 seconds
     - infinite: never stop repeating
     - linear: constant speed (no acceleration) */
}`}/>

### üìö Understanding Percentage Keyframes:

**Why use percentages?** They give you precise control over when changes happen:
- **0%** = Animation start (same as `from`)
- **25%** = Quarter way through
- **50%** = Halfway point  
- **75%** = Three-quarters through
- **100%** = Animation end (same as `to`)

**Timing calculation:** If animation is 3 seconds:
- 0% = 0 seconds
- 50% = 1.5 seconds  
- 100% = 3 seconds

### üéÆ Experiment Time:
1. In **`@keyframes rainbow`**, **add more colors** - try adding `25% { background-color: pink; }` between existing percentages
2. In **`@keyframes rainbow`**, **change timing** - make orange last longer by moving `33.33%` to `40%` (closer to the 16.66% orange)
3. In **`@keyframes rainbow`**, **try different properties** - add `transform: scale(1.1);` at `50%` alongside the green color
4. In **`@keyframes rainbow`**, **mix properties** - animate color AND size together at `50%`:
   ```css
   50% { 
     background-color: green; 
     transform: scale(1.2); 
   }
   ```


## Mastering Animation Timing Functions

Timing functions control the acceleration curve of your animations - they're what makes animations feel natural or mechanical:

<SeparatedEditorPreview 
  title="‚è±Ô∏è Timing Functions Comparison"
  mission="Compare different animation timing functions side by side"
  instructions="Watch each box carefully - notice how they accelerate differently even though they travel the same distance"
initialHtml={`<div class="timing-demo">
  <div class="box ease">ease (default)</div>
  <div class="box linear">linear</div>
  <div class="box ease-in">ease-in</div>
  <div class="box ease-out">ease-out</div>
  <div class="box ease-in-out">ease-in-out</div>
  <div class="box cubic">cubic-bezier (bouncy!)</div>
</div>`}
initialCss={`/* Same animation for all boxes */
@keyframes slideRight {
  from {
    transform: translateX(0);     /* Start position */
  }
  to {
    transform: translateX(200px); /* End position */
  }
}

.timing-demo {
  padding: 20px;
  background: #f5f5f5;
  border-radius: 8px;
}

/* Base styles for all boxes */
.box {
  width: 80px;
  height: 40px;
  margin: 10px 0;
  background: #3498db;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  font-weight: bold;
  border-radius: 4px;
  
  /* Same animation settings for all */
  animation: slideRight 2s infinite alternate;
  /* alternate = goes back and forth */
}

/* Different timing functions create different "feels" */
.ease { 
  animation-timing-function: ease; 
  /* Slow start ‚Üí fast middle ‚Üí slow end (most natural) */
}

.linear { 
  animation-timing-function: linear; 
  /* Constant speed throughout (robotic feel) */
}

.ease-in { 
  animation-timing-function: ease-in; 
  /* Slow start ‚Üí fast end (like falling) */
}

.ease-out { 
  animation-timing-function: ease-out; 
  /* Fast start ‚Üí slow end (like braking) */
}

.ease-in-out { 
  animation-timing-function: ease-in-out; 
  /* Slow start ‚Üí fast middle ‚Üí slow end (very smooth) */
}

.cubic { 
  animation-timing-function: cubic-bezier(0.68, -0.55, 0.265, 1.55); 
  /* Custom curve with bounce/overshoot effect */
}`}/>

### üìö Timing Functions Explained:

**Think of timing functions like driving styles:**

1. **`ease`** (default) - Like a careful driver: starts slow, speeds up for efficiency, then slows down to arrive smoothly
2. **`linear`** - Like cruise control: constant speed, feels robotic but good for loading spinners  
3. **`ease-in`** - Like rolling down a hill: starts slow, gains momentum
4. **`ease-out`** - Like hitting the brakes: starts fast, slows down to stop
5. **`ease-in-out`** - Like a professional driver: smooth acceleration and deceleration
6. **`cubic-bezier()`** - Custom curve! You control the exact acceleration pattern

### üéÆ Advanced Challenge:
1. In all **`.box`** classes, **change all durations** from `animation: slideRight 2s` to `4s` - now you can really see the differences!
2. **Try these custom cubic-beziers:**
   - In **`.cubic`**: Replace the existing cubic-bezier with `cubic-bezier(0.68, -0.55, 0.265, 1.55)` for more bounce
   - In **`.ease`**: Try `cubic-bezier(0.25, 0.46, 0.45, 0.94)` for elastic feel
   - In **`.linear`**: Try `cubic-bezier(0.25, 1, 0.5, 1)` for sharp acceleration
3. In **`@keyframes slideRight`**, **mix with other properties:**
   ```css
   to {
     transform: translateX(200px) scale(1.5);
   }
   ```


## Building Complex Loading Animations

Professional loading spinners combine multiple animations and precise timing:

<SeparatedEditorPreview 
  title="üîÑ Professional Loading Spinner"
  mission="Create a sophisticated loading animation with multiple moving parts"
  instructions="Study how animation delays create the wave effect, then try creating your own pattern"
initialHtml={`<div class="spinner-container">
  <div class="spinner">
    <div class="dot dot-1"></div>
    <div class="dot dot-2"></div>
    <div class="dot dot-3"></div>
    <div class="dot dot-4"></div>
  </div>
  <div class="loading-text">Loading...</div>
</div>`}
initialCss={`/* Animation 1: Spin effect (not used here but good to have) */
@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);    /* Full rotation */
  }
}

/* Animation 2: Pulse effect for the dots */
@keyframes pulse {
  0%, 80%, 100% {
    transform: scale(0);   /* Start and end: invisible and tiny */
    opacity: 0;           /* Completely transparent */
  }
  40% {
    transform: scale(1);   /* Middle: full size */
    opacity: 1;           /* Fully visible */
  }
}

/* Animation 3: Text fade for loading text */
@keyframes textFade {
  0%, 50% {
    opacity: 0.3;
  }
  100% {
    opacity: 1;
  }
}

.spinner-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 200px;
  background: #2c3e50;
  gap: 20px;
}

.spinner {
  position: relative;
  width: 40px;
  height: 40px;
}

/* Each dot is positioned in a diamond pattern */
.dot {
  position: absolute;
  width: 10px;
  height: 10px;
  background: #3498db;
  border-radius: 50%;
  
  /* All dots use same animation but with different delays */
  animation: pulse 1.5s infinite ease-in-out;
}

/* Strategic positioning and timing delays */
.dot-1 {
  top: 0;              /* Top center */
  left: 15px;
  animation-delay: 0s; /* Starts immediately */
}

.dot-2 {
  top: 15px;           /* Right center */
  right: 0;
  animation-delay: -0.375s; /* Starts 0.375s earlier (creates wave effect) */
}

.dot-3 {
  bottom: 0;           /* Bottom center */
  left: 15px;
  animation-delay: -0.75s;  /* Starts 0.75s earlier */
}

.dot-4 {
  top: 15px;           /* Left center */
  left: 0;
  animation-delay: -1.125s; /* Starts 1.125s earlier */
}

.loading-text {
  color: white;
  font-family: Arial, sans-serif;
  font-size: 14px;
  animation: textFade 2s infinite ease-in-out;
}`}/>

### üìö Complex Animation Breakdown:

**The secret to professional loading animations:**

1. **Strategic Positioning** - Dots arranged in a diamond pattern using absolute positioning
2. **Animation Delays** - Each dot starts at a different time creating a wave effect:
   - Dot 1: 0s delay (starts first)
   - Dot 2: -0.375s delay (starts 0.375s earlier in the cycle)
   - Dot 3: -0.75s delay (starts 0.75s earlier)
   - Dot 4: -1.125s delay (starts 1.125s earlier)

3. **Negative Delays** - Using negative delays makes dots start at different points in their cycle
4. **Scale + Opacity** - Combining size and transparency changes for smooth appearance/disappearance

### üéÆ Creative Challenges:
1. **Change the pattern** - In **`.dot-1, .dot-2, .dot-3, .dot-4`** positioning, move dots to form a square (try `top: 0, right: 0, bottom: 0, left: 0`)
2. **Add rotation** - In **`.spinner`**, give the whole container a spin animation:
   ```css
   .spinner {
     animation: spin 3s linear infinite;
   }
   ```
3. **Try different colors** - In **`.dot-1, .dot-2, .dot-3, .dot-4`**, make each dot a different `background` color
4. **Experiment with delays** - In **`.dot-2, .dot-3, .dot-4`**, try faster waves with `-0.2s, -0.4s, -0.6s` instead of current delays
5. **Add more dots** - Create **`.dot-5, .dot-6, .dot-7, .dot-8`** with appropriate positioning and delays for smoother motion


## Animation Direction and Fill Mode

Control how animations behave before, during, and after execution:

<SeparatedEditorPreview 
  title="Animation Direction and Fill Mode"
  mission="Explore different animation behaviors"
  instructions="See how direction and fill-mode affect animation playback"
initialHtml={`
<div class="animation-controls">
  <div class="demo-box normal">normal</div>
  <div class="demo-box reverse">reverse</div>
  <div class="demo-box alternate">alternate</div>
  <div class="demo-box alternate-reverse">alternate-reverse</div>
</div>
`}
initialCss={`
@keyframes slideAndColor {
  0% {
    transform: translateX(0);
    background-color: #e74c3c;
  }
  100% {
    transform: translateX(150px);
    background-color: #27ae60;
  }
}

.animation-controls {
  padding: 20px;
  background: #ecf0f1;
}

.demo-box {
  width: 100px;
  height: 50px;
  margin: 15px 0;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: bold;
  font-size: 12px;
  border-radius: 4px;
  
  animation-duration: 2s;
  animation-iteration-count: infinite;
  animation-timing-function: ease-in-out;
  animation-fill-mode: both;
}

.normal {
  animation-name: slideAndColor;
  animation-direction: normal;
}

.reverse {
  animation-name: slideAndColor;
  animation-direction: reverse;
}

.alternate {
  animation-name: slideAndColor;
  animation-direction: alternate;
}

.alternate-reverse {
  animation-name: slideAndColor;
  animation-direction: alternate-reverse;
}
`}/>


## Hover-Triggered Animations

Create interactive animations that respond to user interaction:

<SeparatedEditorPreview 
  title="Interactive Button Animations"
  mission="Create engaging button hover effects"
  instructions="Animate buttons on hover with smooth transitions and creative effects"
initialHtml={`
<div class="button-gallery">
  <button class="btn btn-scale">Scale Up</button>
  <button class="btn btn-slide">Slide Effect</button>
  <button class="btn btn-rotate">Rotate</button>
  <button class="btn btn-glow">Glow Effect</button>
</div>
`}
initialCss={`
@keyframes scaleUp {
  from {
    transform: scale(1);
  }
  to {
    transform: scale(1.1);
  }
}

@keyframes slideIn {
  from {
    transform: translateX(-100%);
  }
  to {
    transform: translateX(0);
  }
}

@keyframes rotateIn {
  from {
    transform: rotateY(0deg);
  }
  to {
    transform: rotateY(360deg);
  }
}

@keyframes glow {
  0%, 100% {
    box-shadow: 0 0 5px #3498db;
  }
  50% {
    box-shadow: 0 0 20px #3498db, 0 0 30px #3498db;
  }
}

.button-gallery {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 20px;
  padding: 20px;
  background: #34495e;
}

.btn {
  padding: 12px 24px;
  border: none;
  border-radius: 6px;
  background: #3498db;
  color: white;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.btn-scale:hover {
  animation: scaleUp 0.3s ease forwards;
}

.btn-slide::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.2);
  transition: left 0.3s ease;
}

.btn-slide:hover::before {
  left: 100%;
}

.btn-rotate:hover {
  animation: rotateIn 0.6s ease;
}

.btn-glow:hover {
  animation: glow 1s ease infinite;
}
`}/>


## Advanced Animation Techniques

Create sophisticated animations with multiple properties:

<SeparatedEditorPreview 
  title="Advanced Card Animation"
  mission="Create a sophisticated card flip animation"
  instructions="Combine 3D transforms and timing for a realistic card flip effect"
initialHtml={`
<div class="card-container">
  <div class="card">
    <div class="card-front">
      <h3>Front Side</h3>
      <p>Hover to flip!</p>
    </div>
    <div class="card-back">
      <h3>Back Side</h3>
      <p>Amazing flip effect!</p>
    </div>
  </div>
</div>
`}
initialCss={`
@keyframes cardEntry {
  from {
    transform: translateY(50px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.card-container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 300px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  perspective: 1000px;
}

.card {
  width: 250px;
  height: 200px;
  position: relative;
  transform-style: preserve-3d;
  transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  animation: cardEntry 1s ease-out;
}

.card:hover {
  transform: rotateY(180deg);
}

.card-front,
.card-back {
  position: absolute;
  width: 100%;
  height: 100%;
  backface-visibility: hidden;
  border-radius: 12px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  color: white;
  font-family: Arial, sans-serif;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

.card-front {
  background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
}

.card-back {
  background: linear-gradient(135deg, #00d2d3 0%, #54a0ff 100%);
  transform: rotateY(180deg);
}

.card h3 {
  margin: 0 0 10px 0;
  font-size: 24px;
}

.card p {
  margin: 0;
  font-size: 16px;
  opacity: 0.9;
}
`}/>


## Performance Optimization

When creating animations, always consider performance:

### Best Practices for Smooth Animations

1. **Use Transform and Opacity**: These properties are GPU-accelerated
2. **Avoid Animating Layout Properties**: Don't animate width, height, margins
3. **Use `will-change` Property**: Tell the browser what will be animated
4. **Reduce Animation Complexity**: Fewer keyframes = better performance
5. **Use Hardware Acceleration**: `transform: translateZ(0)` forces GPU rendering

<SeparatedEditorPreview 
  title="Performance-Optimized Animation"
  mission="Create smooth, GPU-accelerated animations"
  instructions="Use transforms and opacity for the best performance"
initialHtml={`
<div class="performance-demo">
  <div class="optimized-element">
    GPU Optimized
  </div>
  <div class="slow-element">
    CPU Heavy
  </div>
</div>
`}
initialCss={`
@keyframes smoothMove {
  0% {
    transform: translateX(0) scale(1);
    opacity: 1;
  }
  50% {
    transform: translateX(100px) scale(1.2);
    opacity: 0.7;
  }
  100% {
    transform: translateX(200px) scale(1);
    opacity: 1;
  }
}

@keyframes heavyMove {
  0% {
    left: 0;
    width: 100px;
    background-color: red;
  }
  50% {
    left: 100px;
    width: 120px;
    background-color: orange;
  }
  100% {
    left: 200px;
    width: 100px;
    background-color: green;
  }
}

.performance-demo {
  padding: 40px 20px;
  background: #2c3e50;
  position: relative;
  height: 200px;
}

.optimized-element,
.slow-element {
  width: 100px;
  height: 50px;
  position: absolute;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
  border-radius: 4px;
}

.optimized-element {
  top: 50px;
  background: #27ae60;
  will-change: transform, opacity;
  animation: smoothMove 3s infinite ease-in-out;
}

.slow-element {
  top: 120px;
  left: 0;
  background: #e74c3c;
  animation: heavyMove 3s infinite ease-in-out;
}
`}/>


## Animation Shorthand

You can combine all animation properties in one declaration:
```css
/* animation: name duration timing-function delay iteration-count direction fill-mode play-state; */

.element {
  animation: slideIn 1s ease-in-out 0.5s infinite alternate both running;
}
```

## Browser Support and Fallbacks

Always provide fallbacks for older browsers:
```css
.element {
  /* Fallback for older browsers */
  opacity: 0;
  
  /* Modern animation */
  animation: fadeIn 1s ease-out forwards;
}

@supports (animation: fadeIn 1s ease-out) {
  .element {
    opacity: 0;
  }
}
```

## üß† Test Your CSS Animation Knowledge

Time to put your animation skills to the test! This quiz covers all the concepts we've learned:

<SeparatedEditorPreview 
  title="üéØ CSS Animation Challenge Quiz"
  mission="Complete these animation challenges to test your knowledge"
  instructions="Try to solve each challenge using the concepts we've covered. Check your answers against the solutions!"
initialHtml={`<!-- Challenge 1: Create a bouncing ball -->
<div class="quiz-section">
  <h3>Challenge 1: Bouncing Ball</h3>
  <p>Make the ball bounce up and down continuously</p>
  <div class="ball challenge-1"></div>
</div>

<!-- Challenge 2: Create a pulsing heart -->
<div class="quiz-section">
  <h3>Challenge 2: Pulsing Heart</h3>
  <p>Make the heart pulse with a gentle scaling effect</p>
  <div class="heart challenge-2">‚ù§Ô∏è</div>
</div>

<!-- Challenge 3: Create a rotating loader -->
<div class="quiz-section">
  <h3>Challenge 3: Spinning Loader</h3>
  <p>Create a rotating border spinner</p>
  <div class="spinner challenge-3"></div>
</div>

<!-- Challenge 4: Create a slide-in text -->
<div class="quiz-section">
  <h3>Challenge 4: Slide-In Text</h3>
  <p>Make text slide in from the left with a bounce</p>
  <div class="text-slide challenge-4">Hello Animation!</div>
</div>

<!-- Solutions (uncomment to see answers) -->
<div class="solutions">
  <h3>üîç Solutions (Try first, then check!)</h3>
  <details>
    <summary>Click to see solutions</summary>
    <p><strong>Challenge 1:</strong> Use translateY() with alternate direction</p>
    <p><strong>Challenge 2:</strong> Use scale() with ease-in-out timing</p>
    <p><strong>Challenge 3:</strong> Use rotate(360deg) with linear timing</p>
    <p><strong>Challenge 4:</strong> Use translateX() with cubic-bezier bounce</p>
  </details>
</div>`}
initialCss={`/* Base Styles */
.quiz-section {
  background: white;
  margin: 20px 0;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  border-left: 4px solid #3498db;
}

.quiz-section h3 {
  color: #3498db;
  margin-top: 0;
}

.quiz-section p {
  color: #666;
  font-style: italic;
  margin-bottom: 15px;
}

/* Challenge Elements */
.ball {
  width: 30px;
  height: 30px;
  background: linear-gradient(45deg, #ff6b6b, #ff5722);
  border-radius: 50%;
  margin: 20px auto;
}

.heart {
  font-size: 30px;
  text-align: center;
  margin: 20px 0;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #f3f3f3;
  border-top: 4px solid #3498db;
  border-radius: 50%;
  margin: 20px auto;
}

.text-slide {
  font-size: 18px;
  font-weight: bold;
  color: #2c3e50;
  text-align: center;
  padding: 10px;
}

.solutions {
  background: #f8f9fa;
  padding: 20px;
  border-radius: 8px;
  margin-top: 30px;
}

.solutions details {
  cursor: pointer;
}

.solutions summary {
  font-weight: bold;
  color: #27ae60;
  padding: 10px;
  background: white;
  border-radius: 4px;
  margin-bottom: 10px;
}

.solutions p {
  margin: 10px 0;
  padding: 8px;
  background: white;
  border-left: 3px solid #27ae60;
  border-radius: 4px;
}

/* YOUR CHALLENGE: Add animations below! */

/* Challenge 1: Bouncing Ball Animation */
@keyframes bounce {
  /* Add your keyframes here for the bouncing ball */
  /* Hint: Use translateY() to move up and down */
  /* Try: In this @keyframes, set 0% and 100% at bottom, 50% at top */
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-50px); }
}

.challenge-1 {
  /* Add animation properties here for the .ball element */
  /* Uncomment this line: animation: bounce 1s infinite ease-in-out; */
  animation: bounce 1s infinite ease-in-out;
}

/* Challenge 2: Pulsing Heart Animation */
@keyframes pulse {
  /* Add your keyframes here for the heart pulsing effect */
  /* Hint: Use scale() to make the .heart element grow and shrink */
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.2); }
}

.challenge-2 {
  /* Add animation properties here for the .heart element */
  /* Uncomment this line: animation: pulse 1.5s infinite ease-in-out; */
  animation: pulse 1.5s infinite ease-in-out;
}

/* Challenge 3: Spinning Loader Animation */
@keyframes spin {
  /* Add your keyframes here for the spinning loader */
  /* Hint: Use rotate() from 0deg to 360deg on the .spinner element */
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.challenge-3 {
  /* Add animation properties here for the .spinner element */
  /* Uncomment this line: animation: spin 2s infinite linear; */
  animation: spin 2s infinite linear;
}

/* Challenge 4: Slide-in Text Animation */
@keyframes slideInBounce {
  /* Add your keyframes here for the sliding text effect */
  /* Hint: Start from translateX(-100%) for the .text-slide element and use cubic-bezier for bounce */
  0% {
    transform: translateX(-200px);
    opacity: 0;
  }
  60% {
    transform: translateX(20px);
    opacity: 1;
  }
  80% {
    transform: translateX(-10px);
  }
  100% {
    transform: translateX(0);
  }
}

.challenge-4 {
  /* Add animation properties here for the .text-slide element */
  /* Uncomment this line: animation: slideInBounce 2s ease-out; */
  animation: slideInBounce 2s ease-out;
}`}/>

### üìù Quiz Questions to Test Your Understanding:

**Question 1:** What's the difference between `from/to` and percentage keyframes?
- A) No difference, they're the same
- B) `from/to` only works with 2 steps, percentages allow multiple steps
- C) Percentages are faster
- D) `from/to` is deprecated

<details>
<summary>Answer</summary>
**B) Correct!** `from/to` is shorthand for `0%/100%` and only defines start/end states. Percentages let you create complex multi-step animations.
</details>

**Question 2:** Which timing function creates the most natural feeling animation?
- A) linear
- B) ease
- C) ease-in
- D) steps()

<details>
<summary>Answer</summary>
**B) ease** - It mimics natural motion with slow start, fast middle, slow end - like how we naturally move in the real world.
</details>

**Question 3:** What does `animation-delay: -0.5s` do?
- A) Delays the animation by 0.5 seconds
- B) Starts the animation 0.5 seconds earlier in its cycle
- C) Makes the animation 0.5 seconds shorter
- D) Creates an error

<details>
<summary>Answer</summary>
**B) Correct!** Negative delays make animations start partway through their cycle, great for creating wave effects.
</details>

**Question 4:** Which properties are GPU-accelerated for best performance?
- A) width, height, left, top
- B) transform, opacity
- C) margin, padding
- D) color, background-color

<details>
<summary>Answer</summary>
**B) transform and opacity** are GPU-accelerated! They don't trigger layout recalculation, making animations buttery smooth.
</details>

**Question 5:** What does `animation-direction: alternate` do?
- A) Plays animation backwards
- B) Plays animation forward then backward repeatedly
- C) Alternates between different animations
- D) Chooses a random direction

<details>
<summary>Answer</summary>
**B) Correct!** `alternate` makes the animation go forward, then backward, then forward again - perfect for back-and-forth motion.
</details>

### üéÆ Extra Credit Challenge:

Create a complex animation that combines:
1. **A spinning element** - Use `transform: rotate()` in **`@keyframes complexAnimation`**
2. **A pulsing effect** - Use `transform: scale()` in the same keyframes
3. **A color change** - Use `background-color` transitions at different percentages
4. **Custom cubic-bezier timing** - Apply to **`.complex-element`** class

```css
@keyframes complexAnimation {
  0% {
    transform: rotate(0deg) scale(1);     /* Start: normal size, no rotation */
    background-color: #3498db;            /* Blue at start */
  }
  50% {
    transform: rotate(180deg) scale(1.5); /* Halfway: half rotation, 1.5x size */
    background-color: #e74c3c;            /* Red at middle */
  }
  100% {
    transform: rotate(360deg) scale(1);   /* End: full rotation, back to normal size */
    background-color: #27ae60;            /* Green at end */
  }
}

.complex-element {
  /* Apply the complex animation to any element with this class */
  animation: complexAnimation 3s infinite cubic-bezier(0.68, -0.55, 0.265, 1.55);
  /* 3s duration, infinite loop, bouncy cubic-bezier timing */
}
```

**üéØ Try These Modifications:**
- In **`@keyframes complexAnimation`** at `50%`, change `scale(1.5)` to `scale(2)` for more dramatic pulsing
- In **`.complex-element`**, try different cubic-bezier values like `cubic-bezier(0.25, 0.46, 0.45, 0.94)` for elastic motion
- Add more keyframes at `25%` and `75%` with different colors and scales
- Change `rotate(360deg)` to `rotate(720deg)` for double rotation

## Conclusion

Congratulations! You've mastered CSS animations! üéâ You can now:

- ‚úÖ Create keyframe animations with multiple steps
- ‚úÖ Control timing, direction, and repetition like a pro
- ‚úÖ Build complex, multi-property animations
- ‚úÖ Optimize animations for smooth, GPU-accelerated performance
- ‚úÖ Create interactive hover effects that delight users
- ‚úÖ Use advanced timing functions and animation delays
- ‚úÖ Combine multiple animations for sophisticated effects

### üöÄ Key Takeaways:

1. **Keyframes are your foundation** - Master `@keyframes` with percentages for complex sequences
2. **Timing functions create personality** - `ease` feels natural, `linear` feels robotic
3. **Performance matters** - Use `transform` and `opacity` for buttery smooth animations
4. **Animation delays create magic** - Negative delays make wave effects possible
5. **Less is often more** - Subtle animations enhance UX without overwhelming users

CSS animations are a powerful tool for creating engaging user experiences. Remember to use them purposefully - they should enhance usability and delight users, not distract from your content!

## What's Next?

In the next tutorial, we'll explore **Responsive Design & Media Queries**, where you'll learn to create layouts that work perfectly on any device size - and make your animations responsive too!