---
title: "TypeScript Interfaces - The Ultimate Contracts"
description: "Master TypeScript interfaces to define bulletproof contracts for your code. Learn interface implementation, extension, and advanced patterns"
difficulty: 3
estimatedTime: "35 minutes"
prerequisites: ["typescript-classes", "typescript-oop"]
category: "oop"
---

# TypeScript Interfaces - The Ultimate Contracts

Welcome to one of TypeScript's most powerful features! 📜 **Interfaces are like contracts or blueprints that say "If you want to be this type of thing, you MUST have these properties and methods."**

Think about it like this: **What makes something "flyable"?** It needs to be able to take off, fly, and land, right? **What makes something "swimmable"?** It should be able to dive in, swim around, and surface.

**That's exactly what interfaces do!** They define the "what" without worrying about the "how."

## Why Interfaces Are Game-Changing 🚀

**Here's what blew my mind about interfaces:** They let you write code that works with ANY object that has the right "shape," regardless of what class it came from. It's like having a universal adapter that works with anything that fits the right pattern!

**Key benefits of interfaces:**
- **Contracts** 📋 - Guarantee what properties and methods exist
- **Flexibility** 🤸 - Work with any object that matches the shape
- **Documentation** 📚 - Self-documenting code that's easy to understand
- **Type Safety** 🛡️ - Catch mistakes at compile time
- **Polymorphism** 🎭 - Different classes, same interface

## Basic Interface Implementation

Let's start with a classic example that shows the power of interfaces:

<InteractiveCodeBlock editable={true} language="typescript">
{`// 🕊️ Interface for anything that can fly
interface Flyable {
  altitude: number;           // How high are we?
  fly(): void;               // Take to the skies!
  land(): void;              // Come back down safely
}

// 🏊 Interface for anything that can swim  
interface Swimmable {
  depth: number;             // How deep are we?
  swim(): void;              // Get in the water!
  surface(): void;           // Come back up for air
}

// 🦆 A duck can do BOTH! (Multiple interface implementation)
class Duck implements Flyable, Swimmable {
  // ✅ We MUST have all properties from both interfaces
  altitude: number = 0;
  depth: number = 0;
  
  name: string; // We can add our own properties too!
  
  constructor(name: string) {
    this.name = name;
  }

  // ✅ We MUST implement all methods from Flyable
  fly(): void {
    this.altitude = 100;
    console.log(\`🦆 \${this.name} is flying at \${this.altitude} feet!\`);
  }

  land(): void {
    this.altitude = 0;
    console.log(\`🦆 \${this.name} landed safely on the ground.\`);
  }

  // ✅ We MUST implement all methods from Swimmable
  swim(): void {
    this.depth = 5;
    console.log(\`🦆 \${this.name} is swimming \${this.depth} feet underwater!\`);
  }

  surface(): void {
    this.depth = 0;
    console.log(\`🦆 \${this.name} surfaced and is floating happily.\`);
  }

  // 🎵 We can add unique duck methods too!
  quack(): void {
    console.log(\`🦆 \${this.name} says: QUACK QUACK!\`);
  }
}

// 🛩️ What about something that can only fly?
class Airplane implements Flyable {
  altitude: number = 0;
  model: string;
  
  constructor(model: string) {
    this.model = model;
  }
  
  fly(): void {
    this.altitude = 30000;
    console.log(\`✈️ \${this.model} is flying at \${this.altitude} feet!\`);
  }
  
  land(): void {
    this.altitude = 0;
    console.log(\`✈️ \${this.model} landed at the airport.\`);
  }
}

// 🚀 Let's test our interfaces!
const donald = new Duck("Donald");
const boeing = new Airplane("Boeing 747");

console.log("=== Duck Adventures ===");
donald.fly();
donald.swim();
donald.surface();
donald.land();
donald.quack();

console.log("\\n=== Airplane Journey ===");
boeing.fly();
boeing.land();

// 🤔 Here's the cool part - we can treat them the same way!
function makeSomethingFly(flyableObject: Flyable): void {
  flyableObject.fly();
}

console.log("\\n=== Interface Magic ===");
makeSomethingFly(donald);    // Works! Duck implements Flyable
makeSomethingFly(boeing);    // Works! Airplane implements Flyable

// This function accepts ANYTHING that can swim
function makeSomethingSwim(swimmableObject: Swimmable): void {
  swimmableObject.swim();
}

makeSomethingSwim(donald);   // Works! Duck implements Swimmable
// makeSomethingSwim(boeing); // ❌ Error! Airplane doesn't implement Swimmable`}
</InteractiveCodeBlock>

**This is where my mind was BLOWN when I first learned interfaces!** Let me ask you some questions:

1. **What do you think happens if we forget to implement one of the required methods?**
   - TypeScript throws an error! It says "Hey, you promised to implement `swim()` but I don't see it!"

2. **Why can we pass both `donald` and `boeing` to the `makeSomethingFly` function?**
   - Because they both implement the `Flyable` interface! TypeScript knows they both have the required methods.

3. **What's the advantage of this approach?**
   - We can write functions that work with ANY object that implements a specific interface, not just specific classes!

**The magic here is POLYMORPHISM!** The `makeSomethingFly` function doesn't care if you pass it a Duck, Airplane, Bird, or Superhero - as long as it can fly, it works!

## Object Shape Interfaces

Interfaces aren't just for classes! They're perfect for describing the shape of objects:

<InteractiveCodeBlock editable={true} language="typescript">
{`// 👤 Interface for user data
interface User {
  id: number;
  name: string;
  email: string;
  isActive?: boolean;        // ? means optional property
  readonly createdAt: Date;  // readonly means it can't be changed after creation
  preferences?: {            // Nested object interface
    theme: 'light' | 'dark';
    notifications: boolean;
  };
}

// 🔧 Interface for user actions
interface UserActions {
  updateEmail(newEmail: string): void;
  deactivate(): void;
  login(): string;
  logout(): void;
}

// 👑 Interface extending another interface
interface AdminUser extends User {
  permissions: string[];
  lastLogin?: Date;
  canDeleteUsers: boolean;
}

// 🏗️ Class implementing multiple interfaces
class UserAccount implements User, UserActions {
  id: number;
  name: string;
  email: string;
  isActive: boolean = true;
  readonly createdAt: Date;
  preferences?: {
    theme: 'light' | 'dark';
    notifications: boolean;
  };

  constructor(id: number, name: string, email: string) {
    this.id = id;
    this.name = name;
    this.email = email;
    this.createdAt = new Date();
    this.preferences = {
      theme: 'light',
      notifications: true
    };
  }

  updateEmail(newEmail: string): void {
    if (this.isValidEmail(newEmail)) {
      this.email = newEmail;
      console.log(\`📧 Email updated to: \${newEmail}\`);
    } else {
      throw new Error("Invalid email format");
    }
  }

  deactivate(): void {
    this.isActive = false;
    console.log(\`❌ User \${this.name} has been deactivated\`);
  }

  login(): string {
    if (!this.isActive) {
      throw new Error("Account is deactivated");
    }
    console.log(\`👋 Welcome back, \${this.name}!\`);
    return \`User \${this.name} logged in at \${new Date()}\`;
  }

  logout(): void {
    console.log(\`👋 Goodbye, \${this.name}!\`);
  }

  private isValidEmail(email: string): boolean {
    return email.includes("@") && email.includes(".");
  }
}

// 🏗️ Admin user implementation
class AdminAccount implements AdminUser {
  id: number;
  name: string;
  email: string;
  isActive: boolean = true;
  readonly createdAt: Date;
  permissions: string[];
  lastLogin?: Date;
  canDeleteUsers: boolean;

  constructor(id: number, name: string, email: string, permissions: string[]) {
    this.id = id;
    this.name = name;
    this.email = email;
    this.createdAt = new Date();
    this.permissions = permissions;
    this.canDeleteUsers = permissions.includes('delete_users');
  }

  promoteUser(user: User): void {
    if (!this.canDeleteUsers) {
      throw new Error("Insufficient permissions");
    }
    console.log(\`👑 Admin \${this.name} promoted user \${user.name}\`);
  }
}

// 🚀 Let's test our user system!
const regularUser = new UserAccount(1, "Alice", "alice@example.com");
const admin = new AdminAccount(2, "Bob", "bob@admin.com", ["read", "write", "delete_users"]);

console.log("=== Regular User Actions ===");
console.log(regularUser.login());
regularUser.updateEmail("newalice@example.com");

console.log("\\n=== Admin Actions ===");
admin.promoteUser(regularUser);

// 🎯 Functions that work with interfaces
function processUser(user: User): string {
  const status = user.isActive ? "Active" : "Inactive";
  const accountAge = Math.floor((Date.now() - user.createdAt.getTime()) / (1000 * 60 * 60 * 24));
  return \`User: \${user.name} (\${status}) - Account age: \${accountAge} days\`;
}

console.log("\\n=== Processing Users ===");
console.log(processUser(regularUser));
console.log(processUser(admin));`}
</InteractiveCodeBlock>

**Notice the powerful features:**

1. **Optional properties (`?`)** - Properties that may or may not exist
2. **Readonly properties** - Can only be set once, usually in constructor
3. **Interface extension** - AdminUser gets everything from User plus more
4. **Nested interfaces** - Objects within objects with their own shapes
5. **Union types** - Properties that can be one of several specific values

## Function Interfaces

Interfaces can even describe function signatures! This is incredibly powerful:

<InteractiveCodeBlock editable={true} language="typescript">
{`// 🎯 Interface for a function signature
interface Calculator {
  (a: number, b: number): number;
}

// 📊 Interface for a more complex function
interface DataProcessor<T> {
  (data: T[], options?: ProcessOptions): T[];
}

interface ProcessOptions {
  sortBy?: string;
  filterBy?: (item: any) => boolean;
  reverse?: boolean;
}

// ✅ Functions that implement the Calculator interface
const add: Calculator = (a, b) => a + b;
const multiply: Calculator = (a, b) => a * b;
const subtract: Calculator = (a, b) => a - b;

// 🧮 Array of calculator functions
const operations: Calculator[] = [add, multiply, subtract];

// 🎲 Function that takes a Calculator as parameter
function performOperation(calc: Calculator, x: number, y: number): void {
  const result = calc(x, y);
  console.log(\`Result: \${result}\`);
}

console.log("=== Calculator Functions ===");
performOperation(add, 5, 3);
performOperation(multiply, 4, 7);
performOperation(subtract, 10, 6);

// 🔄 More complex example with generics
const processNumbers: DataProcessor<number> = (data, options = {}) => {
  let result = [...data]; // Copy the array
  
  if (options.filterBy) {
    result = result.filter(options.filterBy);
  }
  
  if (options.sortBy === 'asc') {
    result.sort((a, b) => a - b);
  } else if (options.sortBy === 'desc') {
    result.sort((a, b) => b - a);
  }
  
  if (options.reverse) {
    result.reverse();
  }
  
  return result;
};

const processStrings: DataProcessor<string> = (data, options = {}) => {
  let result = [...data];
  
  if (options.filterBy) {
    result = result.filter(options.filterBy);
  }
  
  if (options.sortBy === 'asc') {
    result.sort();
  } else if (options.sortBy === 'desc') {
    result.sort().reverse();
  }
  
  return result;
};

console.log("\\n=== Data Processors ===");
const numbers = [5, 2, 8, 1, 9];
const processed = processNumbers(numbers, { 
  sortBy: 'asc', 
  filterBy: (n) => n > 3 
});
console.log("Processed numbers:", processed);

const words = ["banana", "apple", "cherry", "date"];
const processedWords = processStrings(words, { sortBy: 'asc' });
console.log("Processed words:", processedWords);`}
</InteractiveCodeBlock>

## Generic Interfaces

One of the most powerful features is combining interfaces with generics:

<InteractiveCodeBlock editable={true} language="typescript">
{`// 🗂️ Generic repository interface - works with ANY type!
interface Repository<T> {
  create(item: T): void;
  findById(id: string): T | undefined;
  update(id: string, item: Partial<T>): void;
  delete(id: string): boolean;
  findAll(): T[];
  findBy(predicate: (item: T) => boolean): T[];
}

// 📝 Example entity interfaces
interface Product {
  id: string;
  name: string;
  price: number;
  category: string;
  inStock: boolean;
}

interface Customer {
  id: string;
  name: string;
  email: string;
  orderHistory: string[];
}

// 🏪 Concrete implementation for products
class ProductRepository implements Repository<Product> {
  private products: Map<string, Product> = new Map();

  create(product: Product): void {
    this.products.set(product.id, product);
    console.log(\`➕ Product created: \${product.name}\`);
  }

  findById(id: string): Product | undefined {
    return this.products.get(id);
  }

  update(id: string, updates: Partial<Product>): void {
    const product = this.products.get(id);
    if (product) {
      Object.assign(product, updates);
      console.log(\`📝 Product updated: \${product.name}\`);
    }
  }

  delete(id: string): boolean {
    const deleted = this.products.delete(id);
    if (deleted) {
      console.log(\`🗑️ Product deleted: \${id}\`);
    }
    return deleted;
  }

  findAll(): Product[] {
    return Array.from(this.products.values());
  }

  findBy(predicate: (item: Product) => boolean): Product[] {
    return this.findAll().filter(predicate);
  }
}

// 👥 Concrete implementation for customers
class CustomerRepository implements Repository<Customer> {
  private customers: Map<string, Customer> = new Map();

  create(customer: Customer): void {
    this.customers.set(customer.id, customer);
    console.log(\`👤 Customer created: \${customer.name}\`);
  }

  findById(id: string): Customer | undefined {
    return this.customers.get(id);
  }

  update(id: string, updates: Partial<Customer>): void {
    const customer = this.customers.get(id);
    if (customer) {
      Object.assign(customer, updates);
      console.log(\`📝 Customer updated: \${customer.name}\`);
    }
  }

  delete(id: string): boolean {
    const deleted = this.customers.delete(id);
    if (deleted) {
      console.log(\`🗑️ Customer deleted: \${id}\`);
    }
    return deleted;
  }

  findAll(): Customer[] {
    return Array.from(this.customers.values());
  }

  findBy(predicate: (item: Customer) => boolean): Customer[] {
    return this.findAll().filter(predicate);
  }
}

// 🚀 Let's test our generic repositories!
const productRepo = new ProductRepository();
const customerRepo = new CustomerRepository();

// Create some test data
productRepo.create({
  id: "p1",
  name: "TypeScript Book",
  price: 29.99,
  category: "Books",
  inStock: true
});

productRepo.create({
  id: "p2",
  name: "JavaScript Course",
  price: 99.99,
  category: "Courses",
  inStock: false
});

customerRepo.create({
  id: "c1",
  name: "Alice Johnson",
  email: "alice@example.com",
  orderHistory: ["p1"]
});

console.log("\\n=== Repository Queries ===");
console.log("All products:", productRepo.findAll().map(p => p.name));
console.log("In-stock products:", productRepo.findBy(p => p.inStock).map(p => p.name));
console.log("Customer by ID:", customerRepo.findById("c1")?.name);

// Update examples
productRepo.update("p1", { price: 24.99 });
customerRepo.update("c1", { orderHistory: ["p1", "p2"] });`}
</InteractiveCodeBlock>

## Interface vs Type Aliases

**Quick question:** When should you use `interface` vs `type`? Here's the breakdown:

<InteractiveCodeBlock editable={true} language="typescript">
{`// 🏗️ Interfaces - Great for object shapes and contracts
interface UserInterface {
  name: string;
  age: number;
}

// 📋 Type aliases - Great for unions, primitives, and complex types
type UserType = {
  name: string;
  age: number;
};

type Status = "loading" | "success" | "error";
type ID = string | number;

// ✅ Interfaces can be extended and merged
interface Animal {
  name: string;
}

interface Animal {
  // This gets merged with the above!
  species: string;
}

interface Dog extends Animal {
  breed: string;
}

// ❌ Types cannot be merged like this (would cause error)
// type Animal = { name: string; }
// type Animal = { species: string; } // Error!

// 🎯 When to use what:
// Use INTERFACE when:
// - Defining object shapes
// - Creating contracts for classes
// - You might need to extend or merge later
// - Building public APIs

// Use TYPE when:
// - Creating union types
// - Primitive type aliases
// - Complex computed types
// - Function signatures that won't be extended

console.log("=== Interface vs Type Examples ===");

const dog: Dog = {
  name: "Buddy",
  species: "Canine", // From merged Animal interface
  breed: "Golden Retriever"
};

console.log(\`Dog: \${dog.name} is a \${dog.breed}\`);

function processStatus(status: Status): string {
  switch (status) {
    case "loading": return "Please wait...";
    case "success": return "Done!";
    case "error": return "Something went wrong";
  }
}

console.log(processStatus("loading"));`}
</InteractiveCodeBlock>

## Practical Exercise: Event System

Let's build a complete event system using interfaces:

<InteractiveCodeBlock editable={true} language="typescript">
{`// 🎯 Event interfaces
interface BaseEvent {
  type: string;
  timestamp: Date;
  source?: string;
}

interface UserEvent extends BaseEvent {
  userId: string;
  userName: string;
}

interface SystemEvent extends BaseEvent {
  severity: 'info' | 'warning' | 'error';
  message: string;
}

// 🎧 Event listener interfaces
interface EventListener<T extends BaseEvent> {
  handle(event: T): void;
}

interface EventEmitter {
  addEventListener<T extends BaseEvent>(
    eventType: string, 
    listener: EventListener<T>
  ): void;
  removeEventListener(eventType: string, listener: EventListener<any>): void;
  emit<T extends BaseEvent>(event: T): void;
}

// 🏗️ Implementation
class EventManager implements EventEmitter {
  private listeners: Map<string, EventListener<any>[]> = new Map();

  addEventListener<T extends BaseEvent>(
    eventType: string, 
    listener: EventListener<T>
  ): void {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, []);
    }
    this.listeners.get(eventType)!.push(listener);
    console.log(\`🎧 Listener added for event: \${eventType}\`);
  }

  removeEventListener(eventType: string, listener: EventListener<any>): void {
    const eventListeners = this.listeners.get(eventType);
    if (eventListeners) {
      const index = eventListeners.indexOf(listener);
      if (index > -1) {
        eventListeners.splice(index, 1);
        console.log(\`🚫 Listener removed for event: \${eventType}\`);
      }
    }
  }

  emit<T extends BaseEvent>(event: T): void {
    const eventListeners = this.listeners.get(event.type);
    if (eventListeners) {
      console.log(\`📡 Emitting event: \${event.type}\`);
      eventListeners.forEach(listener => {
        try {
          listener.handle(event);
        } catch (error) {
          console.error(\`Error in event listener for \${event.type}:, error\`);
        }
      });
    }
  }
}

// 🎯 Specific event listeners
class UserActivityLogger implements EventListener<UserEvent> {
  handle(event: UserEvent): void {
    console.log(\`👤 USER EVENT: \${event.userName} performed \${event.type} at \${event.timestamp}\`);
  }
}

class SystemMonitor implements EventListener<SystemEvent> {
  handle(event: SystemEvent): void {
    const emoji = event.severity === 'error' ? '🚨' : 
                  event.severity === 'warning' ? '⚠️' : 'ℹ️';
    console.log(\`\${emoji} SYSTEM [\${event.severity.toUpperCase()}]: \${event.message}\`);
  }
}

class SecurityWatcher implements EventListener<UserEvent> {
  private suspiciousActivity: Map<string, number> = new Map();

  handle(event: UserEvent): void {
    if (event.type === 'failed_login') {
      const current = this.suspiciousActivity.get(event.userId) || 0;
      this.suspiciousActivity.set(event.userId, current + 1);
      
      if (current + 1 >= 3) {
        console.log(\`🚨 SECURITY ALERT: User \${event.userName} has \${current + 1} failed login attempts!\`);
      }
    } else if (event.type === 'login') {
      // Reset on successful login
      this.suspiciousActivity.delete(event.userId);
    }
  }
}

// 🚀 Let's test our event system!
const eventManager = new EventManager();
const userLogger = new UserActivityLogger();
const systemMonitor = new SystemMonitor();
const securityWatcher = new SecurityWatcher();

// Register listeners
eventManager.addEventListener('login', userLogger);
eventManager.addEventListener('logout', userLogger);
eventManager.addEventListener('failed_login', userLogger);
eventManager.addEventListener('failed_login', securityWatcher);
eventManager.addEventListener('login', securityWatcher);
eventManager.addEventListener('system_error', systemMonitor);
eventManager.addEventListener('system_warning', systemMonitor);

console.log("=== Event System Demo ===");

// Emit some events
eventManager.emit<UserEvent>({
  type: 'login',
  timestamp: new Date(),
  userId: 'u1',
  userName: 'Alice'
});

eventManager.emit<SystemEvent>({
  type: 'system_warning',
  timestamp: new Date(),
  severity: 'warning',
  message: 'High memory usage detected'
});

// Simulate failed login attempts
for (let i = 0; i < 4; i++) {
  eventManager.emit<UserEvent>({
    type: 'failed_login',
    timestamp: new Date(),
    userId: 'u2',
    userName: 'Hacker'
  });
}

eventManager.emit<UserEvent>({
  type: 'logout',
  timestamp: new Date(),
  userId: 'u1',
  userName: 'Alice'
});`}
</InteractiveCodeBlock>

## Key Takeaways

1. **Contracts**: Interfaces define what must be implemented, not how
2. **Flexibility**: Work with any object that matches the interface shape
3. **Type Safety**: Catch missing implementations at compile time
4. **Polymorphism**: Different classes can implement the same interface
5. **Extension**: Interfaces can extend other interfaces
6. **Generics**: Make interfaces reusable with different types
7. **Documentation**: Interfaces serve as clear documentation

**Real-world analogy:** Think of interfaces like job descriptions:
- "We need someone who can drive" (Drivable interface)
- "We need someone who can code" (Programmable interface)
- "We need someone who can teach" (Teachable interface)

A person could implement ALL of these interfaces - they'd be a coding teacher who can drive to work! 🚗👩‍🏫💻

**What's Next?**

Now that you understand interfaces, you're ready for:
- **Inheritance** - Building class hierarchies
- **Abstract Classes** - Combining interfaces with concrete implementations
- **Design Patterns** - Advanced patterns using interfaces

Interfaces are the foundation of flexible, maintainable TypeScript code!