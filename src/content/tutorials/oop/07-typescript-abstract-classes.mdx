---
title: "TypeScript Abstract Classes - Ultimate Blueprints"
description: "Master TypeScript abstract classes to create bulletproof templates that force implementation while providing shared functionality"
difficulty: 4
estimatedTime: "35 minutes"
prerequisites: ["typescript-classes", "typescript-inheritance", "typescript-interfaces", "typescript-oop"]
category: "oop"
---

# TypeScript Abstract Classes - The Ultimate Blueprints

**Here's where TypeScript gets REALLY interesting!** 🚀 Abstract classes are like saying "I know what all vehicles should be able to do, but I can't make a generic vehicle - you HAVE to make a specific type!"

**Think about it:** Can you build a generic "vehicle"? Not really! You build cars, motorcycles, boats, planes... but never just a "vehicle." That's exactly what abstract classes capture!

**The key insight:** Abstract classes let you define the template and some common functionality, but force child classes to implement the specific details.

## Why Abstract Classes Are Brilliant 🧠

**Abstract classes solve a fundamental problem:** Sometimes you want to share common code between related classes, but you also want to force those classes to implement specific methods in their own way.

**Key benefits:**
- **Shared Implementation** 🔄 - Common code in one place
- **Enforced Contracts** 📋 - Force children to implement specific methods
- **Type Safety** 🛡️ - Prevent instantiation of incomplete classes
- **Design Guidance** 🎯 - Clear structure for other developers
- **Best of Both Worlds** ⚖️ - Interfaces + concrete implementation

**Real-world analogy:** Think of abstract classes like architectural blueprints for different types of buildings. The blueprint defines the foundation, basic structure, and required features (like "must have a door"), but each specific building type (house, office, factory) implements the details differently.

## Basic Abstract Classes

<InteractiveCodeBlock editable={true} language="typescript">
{`// 🏗️ Abstract class - the ultimate blueprint!
abstract class Vehicle {
  protected brand: string;
  protected year: number;
  protected isRunning: boolean = false;

  constructor(brand: string, year: number) {
    this.brand = brand;
    this.year = year;
  }

  // ✅ CONCRETE method - all vehicles can use this
  getInfo(): string {
    return \`\${this.year} \${this.brand}\`;
  }

  // ✅ CONCRETE method - common functionality  
  getAge(): number {
    return new Date().getFullYear() - this.year;
  }

  // 🔨 ABSTRACT methods - children MUST implement these!
  abstract start(): string;        // Every vehicle starts differently
  abstract stop(): string;         // Every vehicle stops differently  
  abstract getMaxSpeed(): number;  // Every vehicle has different limits
  abstract getFuelType(): string;  // Different fuel types

  // ✅ CONCRETE method that uses abstract methods
  performStartupSequence(): string[] {
    const sequence = [
      \`Checking \${this.getInfo()}...\`,
      \`Fuel type: \${this.getFuelType()}\`,
      this.start(),
      \`Max speed: \${this.getMaxSpeed()} km/h\`,
      \`Ready to go!\`
    ];
    this.isRunning = true;
    return sequence;
  }
}

// 🚗 Car implementation - must implement all abstract methods!
class Car extends Vehicle {
  private engineType: string;
  private doors: number;

  constructor(brand: string, year: number, engineType: string, doors: number = 4) {
    super(brand, year);
    this.engineType = engineType;
    this.doors = doors;
  }

  // ✅ Must implement - car-specific starting
  start(): string {
    return \`🚗 \${this.brand} car engine started (\${this.engineType})\`;
  }

  // ✅ Must implement - car-specific stopping
  stop(): string {
    this.isRunning = false;
    return \`🚗 \${this.brand} car engine stopped\`;
  }

  // ✅ Must implement - car speed limits
  getMaxSpeed(): number {
    return this.engineType.includes("V8") ? 220 : 180; // V8s are faster!
  }

  // ✅ Must implement - car fuel type
  getFuelType(): string {
    return this.engineType.includes("Electric") ? "Electric" : "Gasoline";
  }

  // 🚪 Car-specific method
  openDoors(): string {
    return \`Opening all \${this.doors} doors\`;
  }
}

// 🏍️ Motorcycle implementation - different implementations!
class Motorcycle extends Vehicle {
  private engineSize: number;
  private hasWindshield: boolean;

  constructor(brand: string, year: number, engineSize: number, hasWindshield: boolean = false) {
    super(brand, year);
    this.engineSize = engineSize;
    this.hasWindshield = hasWindshield;
  }

  // ✅ Must implement - motorcycle-specific starting
  start(): string {
    return \`🏍️ \${this.brand} motorcycle roared to life (\${this.engineSize}cc)\`;
  }

  // ✅ Must implement - motorcycle-specific stopping  
  stop(): string {
    this.isRunning = false;
    return \`🏍️ \${this.brand} motorcycle engine shut down\`;
  }

  // ✅ Must implement - motorcycles are fast!
  getMaxSpeed(): number {
    return this.engineSize > 600 ? 250 : 180; // Big engines = more speed
  }

  // ✅ Must implement - motorcycle fuel
  getFuelType(): string {
    return "Gasoline";
  }

  // 🏍️ Motorcycle-specific method
  wheelie(): string {
    if (!this.isRunning) {
      return "Can't do a wheelie - engine is off!";
    }
    return \`🏍️ \${this.brand} motorcycle doing an epic wheelie!\`;
  }
}

// 🚀 Let's test our abstract class system!
// const genericVehicle = new Vehicle("Generic", 2023); // ❌ Error! Can't instantiate abstract class

const myCar = new Car("Tesla", 2023, "Electric", 4);
const myBike = new Motorcycle("Kawasaki", 2022, 650, true);

console.log("=== Car startup sequence ===");
myCar.performStartupSequence().forEach(step => console.log(step));
console.log(myCar.openDoors());

console.log("\\n=== Motorcycle startup sequence ===");  
myBike.performStartupSequence().forEach(step => console.log(step));
console.log(myBike.wheelie());

console.log("\\n=== Stopping vehicles ===");
console.log(myCar.stop());
console.log(myBike.stop());
console.log(myBike.wheelie()); // Try wheelie when stopped

console.log("\\n=== Vehicle ages ===");
console.log(\`Car age: \${myCar.getAge()} years\`);
console.log(\`Bike age: \${myBike.getAge()} years\`);

// 🎭 Polymorphism - treating different vehicles the same way
console.log("\\n=== Polymorphism Magic ===");
const garage: Vehicle[] = [myCar, myBike];
garage.forEach((vehicle, index) => {
  console.log(\`Vehicle \${index + 1}: \${vehicle.getInfo()}\`);
  console.log(\`Fuel type: \${vehicle.getFuelType()}\`);
  console.log(\`Max speed: \${vehicle.getMaxSpeed()} km/h\`);
  console.log("---");
});`}
</InteractiveCodeBlock>

**This is absolutely BRILLIANT!** Let me ask you some questions to make sure you understand the power here:

1. **Why can't we do `new Vehicle("Generic", 2023)`?**
   - Because Vehicle is abstract! TypeScript says "Nope, you must create a specific type of vehicle!"

2. **Notice how `performStartupSequence()` works in the abstract class - what's special about it?**
   - It's a concrete method that calls abstract methods! It provides the structure, but each child class fills in the details!

3. **What happens if we create a Car class but forget to implement `start()`?**
   - TypeScript throws an error: "You promised to implement start() but I don't see it!"

## Abstract Classes vs Interfaces

**Quick question:** When should you use abstract classes vs interfaces? Here's the breakdown:

<InteractiveCodeBlock editable={true} language="typescript">
{`// 🔄 Let's compare abstract classes with interfaces

// 📋 Interface approach - defines contract only
interface Flyable {
  altitude: number;
  fly(): void;
  land(): void;
}

interface Maintainable {
  lastMaintenanceDate: Date;
  performMaintenance(): string;
}

// 🏗️ Abstract class approach - contract + shared implementation
abstract class Aircraft {
  protected model: string;
  protected maxAltitude: number;
  protected currentAltitude: number = 0;
  protected lastMaintenanceDate: Date;
  
  constructor(model: string, maxAltitude: number) {
    this.model = model;
    this.maxAltitude = maxAltitude;
    this.lastMaintenanceDate = new Date();
  }

  // ✅ SHARED concrete method - all aircraft can use this
  getAltitudeStatus(): string {
    const percentage = (this.currentAltitude / this.maxAltitude) * 100;
    return \`\${this.model} at \${this.currentAltitude}ft (\${percentage.toFixed(1)}% of max altitude)\`;
  }

  // ✅ SHARED concrete method - common maintenance logic
  performMaintenance(): string {
    this.lastMaintenanceDate = new Date();
    return \`🔧 \${this.model} maintenance completed on \${this.lastMaintenanceDate.toDateString()}\`;
  }

  // ✅ SHARED method that uses abstract methods
  emergencyLanding(): string[] {
    return [
      "🚨 EMERGENCY PROTOCOL ACTIVATED",
      \`Current status: \${this.getAltitudeStatus()}\`,
      this.prepareForLanding(), // Abstract method - each aircraft type implements differently
      this.land(),              // Abstract method
      "✅ Emergency landing completed"
    ];
  }

  // 🔨 ABSTRACT methods - each aircraft type must implement
  abstract takeOff(): string;
  abstract fly(targetAltitude: number): string;
  abstract land(): string;
  abstract prepareForLanding(): string;
}

// ✈️ Commercial airliner - implements abstract class
class CommercialAirliner extends Aircraft {
  private passengers: number;
  private crewCount: number;

  constructor(model: string, maxAltitude: number, passengers: number, crewCount: number) {
    super(model, maxAltitude);
    this.passengers = passengers;
    this.crewCount = crewCount;
  }

  takeOff(): string {
    this.currentAltitude = 1000; // Initial climbing altitude
    return \`✈️ \${this.model} taking off with \${this.passengers} passengers and \${this.crewCount} crew\`;
  }

  fly(targetAltitude: number): string {
    if (targetAltitude > this.maxAltitude) {
      targetAltitude = this.maxAltitude;
    }
    this.currentAltitude = targetAltitude;
    return \`✈️ \${this.model} cruising at \${targetAltitude}ft with \${this.passengers} passengers\`;
  }

  land(): string {
    this.currentAltitude = 0;
    return \`✈️ \${this.model} landed safely with all \${this.passengers} passengers\`;
  }

  prepareForLanding(): string {
    return \`📢 Flight attendants, prepare cabin for landing. Passengers: \${this.passengers}\`;
  }

  // Airliner-specific methods
  serveRefreshments(): string {
    return \`🍽️ Serving refreshments to \${this.passengers} passengers\`;
  }
}

// 🚁 Helicopter - different implementation of same abstract class
class Helicopter extends Aircraft {
  private rotorSpeed: number = 0;
  private maxRotorSpeed: number = 400; // RPM

  constructor(model: string, maxAltitude: number) {
    super(model, maxAltitude);
  }

  takeOff(): string {
    this.rotorSpeed = this.maxRotorSpeed;
    this.currentAltitude = 100;
    return \`🚁 \${this.model} helicopter rotors spinning at \${this.rotorSpeed} RPM, lifting off\`;
  }

  fly(targetAltitude: number): string {
    if (targetAltitude > this.maxAltitude) {
      targetAltitude = this.maxAltitude;
    }
    this.currentAltitude = targetAltitude;
    return \`🚁 \${this.model} hovering at \${targetAltitude}ft (rotors: \${this.rotorSpeed} RPM)\`;
  }

  land(): string {
    this.currentAltitude = 0;
    this.rotorSpeed = 0;
    return \`🚁 \${this.model} touched down gently, rotors winding down\`;
  }

  prepareForLanding(): string {
    return \`🚁 \${this.model} reducing rotor speed, preparing for precise landing\`;
  }

  // Helicopter-specific methods
  hover(): string {
    return \`🚁 \${this.model} hovering in place at \${this.currentAltitude}ft\`;
  }
}

// 🎯 Interface-only approach for comparison
class Drone implements Flyable, Maintainable {
  altitude: number = 0;
  lastMaintenanceDate: Date = new Date();
  
  constructor(private model: string, private maxAltitude: number) {}

  fly(): void {
    this.altitude = Math.min(this.maxAltitude, 200);
    console.log(\`🤖 \${this.model} drone flying at \${this.altitude}ft\`);
  }

  land(): void {
    this.altitude = 0;
    console.log(\`🤖 \${this.model} drone landed\`);
  }

  performMaintenance(): string {
    this.lastMaintenanceDate = new Date();
    return \`🔧 \${this.model} drone maintenance completed\`;
  }
  
  // ❌ No shared implementation - had to rewrite maintenance logic!
  // ❌ No shared altitude management - had to implement from scratch!
  // ❌ No emergency protocols - would have to implement for each drone class!
}

// 🚀 Let's test both approaches!
console.log("=== Abstract Class Benefits ===");

const boeing747 = new CommercialAirliner("Boeing 747", 35000, 400, 16);
const helicopter = new Helicopter("Apache", 15000);

console.log("\\n--- Airliner Operations ---");
console.log(boeing747.takeOff());
console.log(boeing747.fly(35000));
console.log(boeing747.getAltitudeStatus()); // ✅ Shared method!
console.log(boeing747.performMaintenance()); // ✅ Shared method!
console.log(boeing747.serveRefreshments());

console.log("\\n--- Helicopter Operations ---");
console.log(helicopter.takeOff());
console.log(helicopter.fly(8000));
console.log(helicopter.getAltitudeStatus()); // ✅ Same shared method!
console.log(helicopter.hover());
console.log(helicopter.performMaintenance()); // ✅ Same shared method!

console.log("\\n--- Emergency Procedures ---");
// Both use the same emergency protocol structure but with their own implementations!
boeing747.emergencyLanding().forEach(step => console.log(step));

console.log("\\n--- Interface-Only Approach ---");
const drone = new Drone("DJI Phantom", 1000);
drone.fly();
drone.land();
console.log(drone.performMaintenance());
// ❌ No shared altitude status method
// ❌ No emergency procedures
// ❌ Had to reimplement maintenance logic

console.log("\\n=== When to Use What ===");
console.log("✅ Use ABSTRACT CLASS when:");
console.log("  - You have shared implementation code");
console.log("  - You want to prevent instantiation of the base class");
console.log("  - You need a combination of concrete and abstract methods");
console.log("  - You're modeling 'is-a' relationships");

console.log("\\n✅ Use INTERFACE when:");
console.log("  - You only need to define contracts (no shared code)");
console.log("  - You need multiple inheritance (class can implement many interfaces)");
console.log("  - You're modeling 'can-do' relationships");
console.log("  - You want maximum flexibility");`}
</InteractiveCodeBlock>

**Key takeaways about abstract classes vs interfaces:**

| Abstract Classes | Interfaces |
|------------------|------------|
| Can have concrete methods | Only method signatures |
| Can have constructors | No constructors |
| Single inheritance only | Multiple implementation |
| Can have access modifiers | All members are public |
| "Is-a" relationships | "Can-do" relationships |
| Shared implementation | Pure contracts |

## Advanced Abstract Class Patterns

### Template Method Pattern

<InteractiveCodeBlock editable={true} language="typescript">
{`// 🎯 Template Method Pattern with Abstract Classes
// This pattern defines the skeleton of an algorithm but lets subclasses override specific steps

abstract class DataProcessor<T> {
  // 🏗️ TEMPLATE METHOD - defines the algorithm structure
  public processData(data: T[]): ProcessResult<T> {
    console.log("🚀 Starting data processing pipeline...");
    
    // Step 1: Validate (concrete implementation)
    const validationResult = this.validateData(data);
    if (!validationResult.isValid) {
      return { success: false, error: validationResult.error, data: [] };
    }

    // Step 2: Preprocess (abstract - subclasses must implement)
    const preprocessed = this.preprocessData(data);
    
    // Step 3: Transform (abstract - subclasses must implement)
    const transformed = this.transformData(preprocessed);
    
    // Step 4: Validate transformed data (concrete implementation)
    const finalValidation = this.validateTransformedData(transformed);
    if (!finalValidation.isValid) {
      return { success: false, error: finalValidation.error, data: [] };
    }
    
    // Step 5: Post-process (abstract - subclasses must implement)
    const final = this.postProcessData(transformed);
    
    console.log("✅ Data processing completed successfully");
    return { success: true, data: final };
  }

  // ✅ CONCRETE methods - shared validation logic
  private validateData(data: T[]): { isValid: boolean; error?: string } {
    if (!data || data.length === 0) {
      return { isValid: false, error: "Data array is empty or null" };
    }
    return { isValid: true };
  }

  private validateTransformedData(data: T[]): { isValid: boolean; error?: string } {
    if (!data || data.length === 0) {
      return { isValid: false, error: "Transformation resulted in empty data" };
    }
    return { isValid: true };
  }

  // 🔨 ABSTRACT methods - subclasses must implement these steps
  protected abstract preprocessData(data: T[]): T[];
  protected abstract transformData(data: T[]): T[];
  protected abstract postProcessData(data: T[]): T[];
  
  // ✅ CONCRETE hook method - can be overridden but has default implementation
  protected getProcessingSettings(): ProcessingSettings {
    return {
      enableParallelProcessing: false,
      maxRetries: 3,
      timeout: 30000
    };
  }
}

// Supporting types
interface ProcessResult<T> {
  success: boolean;
  data: T[];
  error?: string;
}

interface ProcessingSettings {
  enableParallelProcessing: boolean;
  maxRetries: number;
  timeout: number;
}

// 📊 Number data processor
class NumberProcessor extends DataProcessor<number> {
  protected preprocessData(data: number[]): number[] {
    console.log("🔢 Preprocessing numbers: removing negatives and NaN");
    return data.filter(n => !isNaN(n) && n >= 0);
  }

  protected transformData(data: number[]): number[] {
    console.log("🔄 Transforming numbers: applying square root");
    return data.map(n => Math.sqrt(n));
  }

  protected postProcessData(data: number[]): number[] {
    console.log("✨ Post-processing numbers: rounding to 2 decimal places");
    return data.map(n => Math.round(n * 100) / 100);
  }

  // Override the hook method for number-specific settings
  protected getProcessingSettings(): ProcessingSettings {
    return {
      enableParallelProcessing: true, // Numbers can be processed in parallel
      maxRetries: 5,
      timeout: 60000
    };
  }
}

// 📝 Text data processor
class TextProcessor extends DataProcessor<string> {
  protected preprocessData(data: string[]): string[] {
    console.log("📝 Preprocessing text: trimming and removing empty strings");
    return data
      .map(s => s.trim())
      .filter(s => s.length > 0);
  }

  protected transformData(data: string[]): string[] {
    console.log("🔄 Transforming text: converting to lowercase and removing special characters");
    return data.map(s => s.toLowerCase().replace(/[^a-z0-9\\s]/g, ''));
  }

  protected postProcessData(data: string[]): string[] {
    console.log("✨ Post-processing text: capitalizing first letter");
    return data.map(s => s.charAt(0).toUpperCase() + s.slice(1));
  }
}

// 🏷️ User data processor
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}

class UserProcessor extends DataProcessor<User> {
  protected preprocessData(data: User[]): User[] {
    console.log("👤 Preprocessing users: filtering out invalid users");
    return data.filter(user => 
      user.id > 0 && 
      user.name && user.name.trim().length > 0 &&
      user.email && user.email.includes('@') &&
      user.age >= 0 && user.age <= 150
    );
  }

  protected transformData(data: User[]): User[] {
    console.log("🔄 Transforming users: normalizing names and emails");
    return data.map(user => ({
      ...user,
      name: user.name.trim().split(' ').map(n => 
        n.charAt(0).toUpperCase() + n.slice(1).toLowerCase()
      ).join(' '),
      email: user.email.toLowerCase().trim()
    }));
  }

  protected postProcessData(data: User[]): User[] {
    console.log("✨ Post-processing users: sorting by name");
    return data.sort((a, b) => a.name.localeCompare(b.name));
  }
}

// 🚀 Let's test the Template Method pattern!
console.log("=== Template Method Pattern Demo ===");

// Test number processing
const numberProcessor = new NumberProcessor();
const numbers = [16, 25, -5, 49, NaN, 36, 0];
console.log("\\n--- Number Processing ---");
console.log("Input:", numbers);
const numberResult = numberProcessor.processData(numbers);
console.log("Result:", numberResult);

// Test text processing
const textProcessor = new TextProcessor();
const texts = ["  Hello World!  ", "", "TypeScript@Rules", "abstract-CLASSES"];
console.log("\\n--- Text Processing ---");
console.log("Input:", texts);
const textResult = textProcessor.processData(texts);
console.log("Result:", textResult);

// Test user processing
const userProcessor = new UserProcessor();
const users: User[] = [
  { id: 1, name: "alice JOHNSON", email: "ALICE@EXAMPLE.COM", age: 30 },
  { id: 0, name: "", email: "invalid", age: -5 }, // Invalid user
  { id: 2, name: "  bob smith  ", email: "bob@test.com", age: 25 },
  { id: 3, name: "charlie BROWN", email: "Charlie@Demo.org", age: 35 }
];
console.log("\\n--- User Processing ---");
console.log("Input:", users);
const userResult = userProcessor.processData(users);
console.log("Result:", userResult);

console.log("\\n=== Template Method Benefits ===");
console.log("✅ Consistent processing pipeline across all data types");
console.log("✅ Shared validation and error handling logic");
console.log("✅ Flexible implementation for each data type");
console.log("✅ Easy to add new processor types");
console.log("✅ Algorithm structure is fixed but steps are customizable");`}
</InteractiveCodeBlock>

### Factory Method Pattern with Abstract Classes

<InteractiveCodeBlock editable={true} language="typescript">
{`// 🏭 Factory Method Pattern using Abstract Classes
// Creates objects without specifying their exact class

abstract class NotificationService {
  // 🏗️ TEMPLATE method that uses factory method
  public sendNotification(message: string, recipient: string): string {
    console.log(\`📋 Processing notification request...\`);
    
    // Create the appropriate notification type (factory method)
    const notification = this.createNotification(message, recipient);
    
    // Validate the notification (shared logic)
    const validation = this.validateNotification(notification);
    if (!validation.isValid) {
      return \`❌ Notification failed: \${validation.error}\`;
    }
    
    // Format the notification (shared logic)
    const formatted = this.formatNotification(notification);
    
    // Send the notification (delegated to concrete implementation)
    const result = notification.send(formatted);
    
    // Log the result (shared logic)
    this.logNotification(notification, result);
    
    return result;
  }

  // 🔨 ABSTRACT factory method - subclasses decide which notification to create
  protected abstract createNotification(message: string, recipient: string): Notification;

  // ✅ CONCRETE methods - shared functionality
  private validateNotification(notification: Notification): { isValid: boolean; error?: string } {
    if (!notification.message || notification.message.trim().length === 0) {
      return { isValid: false, error: "Message cannot be empty" };
    }
    if (!notification.recipient || notification.recipient.trim().length === 0) {
      return { isValid: false, error: "Recipient cannot be empty" };
    }
    return { isValid: true };
  }

  private formatNotification(notification: Notification): string {
    const timestamp = new Date().toISOString();
    return \`[\${timestamp}] \${notification.message}\`;
  }

  private logNotification(notification: Notification, result: string): void {
    console.log(\`📝 Log: \${notification.getType()} notification to \${notification.recipient} - \${result.includes('✅') ? 'SUCCESS' : 'FAILED'}\`);
  }
}

// 📧 Notification interface
interface Notification {
  message: string;
  recipient: string;
  send(formattedMessage: string): string;
  getType(): string;
}

// 📧 Email notification implementation
class EmailNotification implements Notification {
  constructor(
    public message: string,
    public recipient: string,
    private subject: string = "Notification"
  ) {}

  send(formattedMessage: string): string {
    // Simulate email sending logic
    console.log(\`📧 Sending email to \${this.recipient}\`);
    console.log(\`Subject: \${this.subject}\`);
    console.log(\`Body: \${formattedMessage}\`);
    return \`✅ Email sent successfully to \${this.recipient}\`;
  }

  getType(): string {
    return "Email";
  }
}

// 📱 SMS notification implementation
class SMSNotification implements Notification {
  constructor(
    public message: string,
    public recipient: string
  ) {}

  send(formattedMessage: string): string {
    // Simulate SMS sending logic
    const truncatedMessage = formattedMessage.length > 160 ? 
      formattedMessage.substring(0, 157) + "..." : formattedMessage;
    
    console.log(\`📱 Sending SMS to \${this.recipient}\`);
    console.log(\`Message: \${truncatedMessage}\`);
    return \`✅ SMS sent successfully to \${this.recipient}\`;
  }

  getType(): string {
    return "SMS";
  }
}

// 🔔 Push notification implementation
class PushNotification implements Notification {
  constructor(
    public message: string,
    public recipient: string,
    private title: string = "App Notification"
  ) {}

  send(formattedMessage: string): string {
    // Simulate push notification logic
    console.log(\`🔔 Sending push notification to device: \${this.recipient}\`);
    console.log(\`Title: \${this.title}\`);
    console.log(\`Body: \${formattedMessage}\`);
    return \`✅ Push notification sent successfully to \${this.recipient}\`;
  }

  getType(): string {
    return "Push";
  }
}

// 📧 Concrete email service factory
class EmailNotificationService extends NotificationService {
  protected createNotification(message: string, recipient: string): Notification {
    return new EmailNotification(message, recipient, "Important Update");
  }
}

// 📱 Concrete SMS service factory
class SMSNotificationService extends NotificationService {
  protected createNotification(message: string, recipient: string): Notification {
    return new SMSNotification(message, recipient);
  }
}

// 🔔 Concrete push service factory
class PushNotificationService extends NotificationService {
  protected createNotification(message: string, recipient: string): Notification {
    return new PushNotification(message, recipient, "Urgent Alert");
  }
}

// 🎯 Smart notification service that chooses the best method
class SmartNotificationService extends NotificationService {
  protected createNotification(message: string, recipient: string): Notification {
    // Business logic to determine best notification method
    if (recipient.includes('@')) {
      return new EmailNotification(message, recipient, "Smart Notification");
    } else if (recipient.match(/^\\+?[1-9]\\d{1,14}$/)) {
      return new SMSNotification(message, recipient);
    } else {
      return new PushNotification(message, recipient, "Smart Alert");
    }
  }
}

// 🚀 Let's test the Factory Method pattern!
console.log("=== Factory Method Pattern Demo ===");

const emailService = new EmailNotificationService();
const smsService = new SMSNotificationService();
const pushService = new PushNotificationService();
const smartService = new SmartNotificationService();

console.log("\\n--- Email Service ---");
const emailResult = emailService.sendNotification(
  "Your TypeScript course is starting soon!",
  "student@example.com"
);

console.log("\\n--- SMS Service ---");
const smsResult = smsService.sendNotification(
  "Meeting reminder: Team standup in 15 minutes",
  "+1234567890"
);

console.log("\\n--- Push Service ---");
const pushResult = pushService.sendNotification(
  "New feature released! Check out the latest updates.",
  "device-token-12345"
);

console.log("\\n--- Smart Service (Auto-Detection) ---");
console.log("Testing with email:");
smartService.sendNotification("Smart notification test", "user@test.com");

console.log("\\nTesting with phone number:");
smartService.sendNotification("Smart SMS test", "+1987654321");

console.log("\\nTesting with device token:");
smartService.sendNotification("Smart push test", "device-xyz-789");

// 🎭 Polymorphism - all services can be treated the same way
console.log("\\n--- Polymorphism Demo ---");
const services: NotificationService[] = [emailService, smsService, pushService, smartService];
const testMessage = "This is a polymorphic notification test";

services.forEach((service, index) => {
  console.log(\`\\nService \${index + 1}:\`);
  service.sendNotification(testMessage, index % 2 === 0 ? "test@example.com" : "+1122334455");
});

console.log("\\n=== Factory Method Benefits ===");
console.log("✅ Same interface for all notification types");
console.log("✅ Easy to add new notification methods");
console.log("✅ Business logic separated from notification creation");
console.log("✅ Consistent validation and logging across all types");
console.log("✅ Flexible object creation based on runtime conditions");`}
</InteractiveCodeBlock>

## Real-World Exercise: Game Engine Architecture

Let's build a comprehensive game engine using abstract classes:

<InteractiveCodeBlock editable={true} language="typescript">
{`// 🎮 Game Engine with Abstract Classes

// 🎯 Base game entity - all game objects inherit from this
abstract class GameObject {
  protected id: string;
  protected position: { x: number; y: number };
  protected rotation: number = 0;
  protected scale: { x: number; y: number } = { x: 1, y: 1 };
  protected isActive: boolean = true;
  protected children: GameObject[] = [];

  constructor(x: number = 0, y: number = 0) {
    this.id = this.generateId();
    this.position = { x, y };
  }

  private generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }

  // ✅ CONCRETE methods - shared by all game objects
  public setPosition(x: number, y: number): void {
    this.position.x = x;
    this.position.y = y;
  }

  public getPosition(): { x: number; y: number } {
    return { ...this.position };
  }

  public setRotation(degrees: number): void {
    this.rotation = degrees;
  }

  public setScale(scaleX: number, scaleY: number): void {
    this.scale.x = scaleX;
    this.scale.y = scaleY;
  }

  public addChild(child: GameObject): void {
    this.children.push(child);
  }

  public removeChild(childId: string): boolean {
    const index = this.children.findIndex(child => child.id === childId);
    if (index > -1) {
      this.children.splice(index, 1);
      return true;
    }
    return false;
  }

  // 🔄 TEMPLATE method - defines the game loop structure
  public gameUpdate(deltaTime: number): void {
    if (!this.isActive) return;

    // Update this object
    this.update(deltaTime);
    
    // Update all children
    this.children.forEach(child => child.gameUpdate(deltaTime));
    
    // Handle collisions if this object can collide
    if (this.canCollide()) {
      this.handleCollisions();
    }
  }

  public gameRender(renderer: Renderer): void {
    if (!this.isActive) return;

    // Render this object
    this.render(renderer);
    
    // Render all children
    this.children.forEach(child => child.gameRender(renderer));
  }

  // 🔨 ABSTRACT methods - each game object type must implement
  protected abstract update(deltaTime: number): void;
  protected abstract render(renderer: Renderer): void;
  public abstract getType(): string;

  // 🪝 HOOK methods - can be overridden but have default implementations
  protected canCollide(): boolean {
    return false; // Most objects don't collide by default
  }

  protected handleCollisions(): void {
    // Default: do nothing
  }

  protected onDestroy(): void {
    // Default cleanup logic
    this.children.forEach(child => child.destroy());
    this.children = [];
  }

  public destroy(): void {
    this.onDestroy();
    this.isActive = false;
  }

  public getId(): string {
    return this.id;
  }
}

// 🖼️ Simple renderer interface
interface Renderer {
  drawRectangle(x: number, y: number, width: number, height: number, color: string): void;
  drawCircle(x: number, y: number, radius: number, color: string): void;
  drawText(x: number, y: number, text: string, color: string): void;
}

// 🎮 Player character
class Player extends GameObject {
  private health: number = 100;
  private maxHealth: number = 100;
  private speed: number = 200; // pixels per second
  private weapon: Weapon | null = null;

  constructor(x: number, y: number) {
    super(x, y);
  }

  // ✅ Implement abstract methods
  protected update(deltaTime: number): void {
    // Handle input (simplified)
    this.handleInput(deltaTime);
    
    // Update weapon
    if (this.weapon) {
      this.weapon.update(deltaTime);
    }
    
    // Regenerate health slowly
    if (this.health < this.maxHealth) {
      this.health = Math.min(this.maxHealth, this.health + 10 * deltaTime);
    }
  }

  protected render(renderer: Renderer): void {
    // Draw player as blue rectangle
    renderer.drawRectangle(this.position.x - 15, this.position.y - 15, 30, 30, "blue");
    
    // Draw health bar
    const healthPercent = this.health / this.maxHealth;
    renderer.drawRectangle(this.position.x - 15, this.position.y - 25, 30, 5, "red");
    renderer.drawRectangle(this.position.x - 15, this.position.y - 25, 30 * healthPercent, 5, "green");
  }

  public getType(): string {
    return "Player";
  }

  // Override collision detection
  protected canCollide(): boolean {
    return true;
  }

  protected handleCollisions(): void {
    // Check collision with enemies, power-ups, etc.
    console.log(\`Player at (\${this.position.x}, \${this.position.y}) checking collisions\`);
  }

  // Player-specific methods
  private handleInput(deltaTime: number): void {
    // Simplified input handling
    // In a real game, this would read from input manager
    const moveDistance = this.speed * deltaTime;
    
    // Mock some movement
    if (Math.random() > 0.7) {
      this.position.x += (Math.random() - 0.5) * moveDistance;
      this.position.y += (Math.random() - 0.5) * moveDistance;
    }
  }

  public takeDamage(amount: number): string {
    this.health = Math.max(0, this.health - amount);
    if (this.health === 0) {
      return \`💀 Player died!\`;
    }
    return \`🩸 Player took \${amount} damage! Health: \${this.health.toFixed(1)}\`;
  }

  public equipWeapon(weapon: Weapon): void {
    this.weapon = weapon;
    this.addChild(weapon);
  }

  public fire(): string {
    if (this.weapon) {
      return this.weapon.fire(this.position);
    }
    return "No weapon equipped!";
  }
}

// 🔫 Abstract weapon class
abstract class Weapon extends GameObject {
  protected damage: number;
  protected fireRate: number; // shots per second
  protected lastFireTime: number = 0;
  protected ammunition: number;
  protected maxAmmo: number;

  constructor(damage: number, fireRate: number, maxAmmo: number) {
    super(0, 0); // Weapons are positioned relative to their owner
    this.damage = damage;
    this.fireRate = fireRate;
    this.maxAmmo = maxAmmo;
    this.ammunition = maxAmmo;
  }

  // Template method for firing
  public fire(fromPosition: { x: number; y: number }): string {
    const currentTime = Date.now();
    const timeSinceLastFire = currentTime - this.lastFireTime;
    const fireInterval = 1000 / this.fireRate;

    if (timeSinceLastFire < fireInterval) {
      return "🚫 Weapon cooling down...";
    }

    if (this.ammunition <= 0) {
      return "🔄 Need to reload!";
    }

    // Abstract method - each weapon fires differently
    const result = this.performFire(fromPosition);
    
    this.ammunition--;
    this.lastFireTime = currentTime;
    
    return result;
  }

  protected abstract performFire(fromPosition: { x: number; y: number }): string;

  public reload(): string {
    this.ammunition = this.maxAmmo;
    return \`🔄 \${this.getType()} reloaded! Ammo: \${this.ammunition}/\${this.maxAmmo}\`;
  }

  protected update(deltaTime: number): void {
    // Weapons might have visual effects, animations, etc.
  }

  protected render(renderer: Renderer): void {
    // Most weapons are invisible or very small
    renderer.drawCircle(this.position.x, this.position.y, 2, "gray");
  }

  public getAmmoCount(): string {
    return \`\${this.ammunition}/\${this.maxAmmo}\`;
  }
}

// 🔫 Pistol implementation
class Pistol extends Weapon {
  constructor() {
    super(25, 2, 12); // 25 damage, 2 shots/sec, 12 rounds
  }

  protected performFire(fromPosition: { x: number; y: number }): string {
    console.log(\`💥 BANG! Pistol fired from (\${fromPosition.x}, \${fromPosition.y})\`);
    return \`🔫 Pistol fired for \${this.damage} damage! Ammo: \${this.getAmmoCount()}\`;
  }

  public getType(): string {
    return "Pistol";
  }
}

// 🔫 Machine gun implementation
class MachineGun extends Weapon {
  constructor() {
    super(15, 8, 30); // 15 damage, 8 shots/sec, 30 rounds
  }

  protected performFire(fromPosition: { x: number; y: number }): string {
    console.log(\`💥💥 RATATATATA! Machine gun fired from (\${fromPosition.x}, \${fromPosition.y})\`);
    return \`🔫 Machine Gun fired for \${this.damage} damage! Ammo: \${this.getAmmoCount()}\`;
  }

  public getType(): string {
    return "Machine Gun";
  }
}

// 👹 Enemy base class
abstract class Enemy extends GameObject {
  protected health: number;
  protected maxHealth: number;
  protected speed: number;
  protected damage: number;
  protected player: Player | null = null;

  constructor(x: number, y: number, health: number, speed: number, damage: number) {
    super(x, y);
    this.health = health;
    this.maxHealth = health;
    this.speed = speed;
    this.damage = damage;
  }

  protected update(deltaTime: number): void {
    if (this.player) {
      this.moveTowardsPlayer(deltaTime);
    }
    this.performAI(deltaTime);
  }

  private moveTowardsPlayer(deltaTime: number): void {
    if (!this.player) return;

    const playerPos = this.player.getPosition();
    const dx = playerPos.x - this.position.x;
    const dy = playerPos.y - this.position.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (distance > 50) { // Don't get too close
      const moveDistance = this.speed * deltaTime;
      this.position.x += (dx / distance) * moveDistance;
      this.position.y += (dy / distance) * moveDistance;
    }
  }

  // Abstract AI behavior
  protected abstract performAI(deltaTime: number): void;

  protected render(renderer: Renderer): void {
    // Draw health bar
    const healthPercent = this.health / this.maxHealth;
    renderer.drawRectangle(this.position.x - 20, this.position.y - 30, 40, 5, "red");
    renderer.drawRectangle(this.position.x - 20, this.position.y - 30, 40 * healthPercent, 5, "orange");
  }

  protected canCollide(): boolean {
    return true;
  }

  public setTarget(player: Player): void {
    this.player = player;
  }

  public takeDamage(amount: number): string {
    this.health = Math.max(0, this.health - amount);
    if (this.health === 0) {
      this.destroy();
      return \`💀 \${this.getType()} destroyed!\`;
    }
    return \`🩸 \${this.getType()} took \${amount} damage! Health: \${this.health}\`;
  }
}

// 🧟 Zombie enemy
class Zombie extends Enemy {
  private lastMoanTime: number = 0;

  constructor(x: number, y: number) {
    super(x, y, 50, 30, 20); // 50 HP, slow speed, 20 damage
  }

  protected performAI(deltaTime: number): void {
    // Zombies moan occasionally
    const currentTime = Date.now();
    if (currentTime - this.lastMoanTime > 3000) {
      console.log(\`🧟 Zombie at (\${this.position.x.toFixed(1)}, \${this.position.y.toFixed(1)}) moans: "Braaaains..."\`);
      this.lastMoanTime = currentTime;
    }
  }

  protected render(renderer: Renderer): void {
    super.render(renderer); // Health bar
    renderer.drawRectangle(this.position.x - 10, this.position.y - 10, 20, 20, "green");
    renderer.drawText(this.position.x - 5, this.position.y, "🧟", "white");
  }

  public getType(): string {
    return "Zombie";
  }
}

// 🤖 Robot enemy  
class Robot extends Enemy {
  private laserCooldown: number = 0;

  constructor(x: number, y: number) {
    super(x, y, 80, 50, 35); // 80 HP, medium speed, 35 damage
  }

  protected performAI(deltaTime: number): void {
    // Robots can shoot lasers
    this.laserCooldown -= deltaTime;
    
    if (this.laserCooldown <= 0 && this.player) {
      const playerPos = this.player.getPosition();
      const distance = Math.sqrt(
        Math.pow(playerPos.x - this.position.x, 2) + 
        Math.pow(playerPos.y - this.position.y, 2)
      );
      
      if (distance < 150) { // Within range
        console.log(\`🤖 Robot at (\${this.position.x.toFixed(1)}, \${this.position.y.toFixed(1)}) fires laser!\`);
        this.laserCooldown = 2.0; // 2 second cooldown
      }
    }
  }

  protected render(renderer: Renderer): void {
    super.render(renderer); // Health bar
    renderer.drawRectangle(this.position.x - 12, this.position.y - 12, 24, 24, "silver");
    renderer.drawText(this.position.x - 5, this.position.y, "🤖", "blue");
  }

  public getType(): string {
    return "Robot";
  }
}

// 🎮 Simple game manager
class GameManager {
  private gameObjects: GameObject[] = [];
  private player: Player;
  private renderer: MockRenderer;
  private lastUpdateTime: number = Date.now();

  constructor() {
    this.renderer = new MockRenderer();
    this.player = new Player(400, 300);
    this.gameObjects.push(this.player);

    // Add some enemies
    const zombie1 = new Zombie(100, 100);
    const zombie2 = new Zombie(700, 500);
    const robot1 = new Robot(600, 200);
    
    zombie1.setTarget(this.player);
    zombie2.setTarget(this.player);
    robot1.setTarget(this.player);
    
    this.gameObjects.push(zombie1, zombie2, robot1);

    // Give player a weapon
    this.player.equipWeapon(new MachineGun());
  }

  public update(): void {
    const currentTime = Date.now();
    const deltaTime = (currentTime - this.lastUpdateTime) / 1000; // Convert to seconds
    this.lastUpdateTime = currentTime;

    // Update all game objects
    this.gameObjects.forEach(obj => obj.gameUpdate(deltaTime));

    // Clean up destroyed objects
    this.gameObjects = this.gameObjects.filter(obj => obj.getId() !== undefined);
  }

  public render(): void {
    console.log("🎨 === RENDERING FRAME ===");
    this.gameObjects.forEach(obj => obj.gameRender(this.renderer));
    console.log("🎨 === FRAME COMPLETE ===");
  }

  public simulatePlayerAction(): void {
    // Simulate player firing
    console.log(this.player.fire());
  }

  public getGameStats(): string {
    const playerPos = this.player.getPosition();
    const enemyCount = this.gameObjects.filter(obj => obj instanceof Enemy).length;
    return \`Player at (\${playerPos.x.toFixed(1)}, \${playerPos.y.toFixed(1)}) - Enemies: \${enemyCount}\`;
  }
}

// 🖼️ Mock renderer for demonstration
class MockRenderer implements Renderer {
  drawRectangle(x: number, y: number, width: number, height: number, color: string): void {
    console.log(\`🟦 Rectangle: (\${x.toFixed(1)}, \${y.toFixed(1)}) \${width}x\${height} \${color}\`);
  }

  drawCircle(x: number, y: number, radius: number, color: string): void {
    console.log(\`🔵 Circle: (\${x.toFixed(1)}, \${y.toFixed(1)}) r=\${radius} \${color}\`);
  }

  drawText(x: number, y: number, text: string, color: string): void {
    console.log(\`📝 Text: (\${x.toFixed(1)}, \${y.toFixed(1)}) "\${text}" \${color}\`);
  }
}

// 🚀 Let's run our game engine!
console.log("=== Game Engine Demo ===");

const game = new GameManager();

console.log("\\n--- Game Loop Simulation ---");
for (let frame = 0; frame < 3; frame++) {
  console.log(\`\\n🎮 FRAME \${frame + 1}\`);
  console.log(game.getGameStats());
  
  game.update();
  game.simulatePlayerAction();
  
  if (frame === 1) {
    console.log("\\n🖼️ Rendering frame...");
    game.render();
  }
  
  // Simulate frame delay
  console.log("⏱️ Frame complete\\n");
}

console.log("\\n=== Abstract Class Benefits in Game Engine ===");
console.log("✅ Consistent game object lifecycle (update/render)");
console.log("✅ Shared position/transform system");
console.log("✅ Template method for game loop integration");
console.log("✅ Forced implementation of essential methods");
console.log("✅ Easy to add new game object types");
console.log("✅ Polymorphic treatment of all game objects");
console.log("✅ Shared collision and parent-child systems");`}
</InteractiveCodeBlock>

## Key Takeaways

1. **Abstract classes combine interfaces with implementation** - Best of both worlds
2. **Template Method Pattern** - Define algorithm structure, let subclasses fill in details
3. **Factory Method Pattern** - Create objects without specifying exact classes
4. **Forced Implementation** - Abstract methods must be implemented by children
5. **Shared Code** - Concrete methods provide common functionality
6. **Design Guidance** - Clear structure for other developers to follow
7. **Polymorphism** - All children can be treated as the abstract parent type

**When to use Abstract Classes:**
- ✅ You have shared implementation code
- ✅ You want to prevent instantiation of the base class
- ✅ You need both concrete and abstract methods
- ✅ You're modeling "is-a" relationships with shared behavior
- ✅ You want to provide a template for other developers

**Abstract Classes vs Interfaces:**
- **Abstract Classes**: "Is-a" with shared implementation
- **Interfaces**: "Can-do" contracts only

**What's Next?**
You're now ready for:
- **Design Patterns** - Advanced patterns using abstract classes
- **Advanced TypeScript** - Generics, utility types, decorators
- **Real-world Applications** - Building complex systems

Abstract classes are the perfect tool for creating robust, maintainable architectures!