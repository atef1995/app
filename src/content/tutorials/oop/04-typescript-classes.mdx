---
title: "TypeScript Classes Fundamentals"
description: "Master TypeScript classes with type safety, access modifiers, and advanced class features that make JavaScript OOP bulletproof"
difficulty: 3
estimatedTime: "30 minutes"
prerequisites: ["constructor-functions-and-prototypes", "typescript-oop"]
category: "oop"
---

# TypeScript Classes Fundamentals

Welcome to the world of TypeScript classes! üöÄ If JavaScript classes were like driving a regular car, TypeScript classes are like piloting a spaceship with all the advanced controls, safety systems, and autopilot features you could dream of!

**Here's what blew MY mind when I first learned TypeScript classes:** You get all the power of JavaScript's flexibility, but with a safety net that catches your mistakes BEFORE your code even runs. It's like having a really smart friend who constantly whispers "Hey, are you sure about that?" while you're coding.

## Why TypeScript Classes? The Game-Changer!

**Let me ask you something:** How many times have you written JavaScript and thought "I wish my editor could tell me what properties this object has" or "I hope I'm calling this method with the right arguments"?

TypeScript classes are the answer to those prayers! Here's what makes them absolutely incredible:

- **Type Safety** üõ°Ô∏è - Catch typos and errors while you're typing (not when users are crying!)
- **IntelliSense on Steroids** üß† - Your editor becomes a mind reader
- **Access Modifiers** üîí - Control who can touch what (privacy for your code!)
- **Real-time Error Detection** ‚ö° - Know about problems before your users do!

**The best part?** Everything you learned about JavaScript classes still applies - TypeScript just makes it bulletproof!

## Basic Class Definition - Let's Build a Smart Person!

**Before we dive into the code, let me ask you:** What do you think is the biggest difference you'll notice between a JavaScript class and a TypeScript class?

Take a guess... ü§î

**The answer:** TYPE ANNOTATIONS! Every property, parameter, and return value gets a type. It's like giving everything a name tag that says "Hi, I'm a string" or "Hi, I'm a number!"

<InteractiveCodeBlock editable={true} language="typescript">
{`class Person {
  // üè∑Ô∏è Property declarations with types (JavaScript can't do this!)
  private name: string;      // Only this class can see this
  protected age: number;     // This class and its children can see this
  public email: string;      // Everyone can see this (same as no modifier)

  // üîß Constructor with typed parameters
  constructor(name: string, age: number, email: string) {
    this.name = name;
    this.age = age;
    this.email = email;
  }

  // üéØ Method with return type annotation
  greet(): string {
    return "Hello, I'm " + this.name;
  }

  // üìñ Getter (computed property)
  get displayName(): string {
    return this.name;
  }

  // ‚úèÔ∏è Setter with validation
  set displayName(value: string) {
    if (value.length < 2) {
      throw new Error("Name must be at least 2 characters");
    }
    this.name = value;
  }

  // üßÆ Let's add a method that shows TypeScript's power
  celebrateBirthday(): string {
    this.age++; // TypeScript KNOWS this is a number!
    return \`üéâ Happy birthday! Now I'm \${this.age} years old.\`;
  }
}

// üöÄ Let's test our TypeScript class!
const alice = new Person("Alice", 25, "alice@example.com");

console.log(alice.greet());
console.log(alice.celebrateBirthday());

// üîí Try accessing private property (this will cause an error!)
// console.log(alice.name); // ‚ùå Error: Property 'name' is private

// ‚úÖ But we can use the getter!
console.log("Display name:", alice.displayName);

// üõ°Ô∏è Type safety in action - try passing wrong types!
// const bob = new Person(123, "Bob", true); // ‚ùå TypeScript catches this!

console.log("Email is accessible:", alice.email); // ‚úÖ Public property works!`}
</InteractiveCodeBlock>

**WHOA! Did you see all that magic happening?** Let me break down what just blew my mind:

1. **`private name: string`** - TypeScript literally won't let you access `alice.name` from outside the class!
2. **Typed parameters** - If you try to pass a number where a string is expected, TypeScript stops you cold
3. **Return type annotations** - TypeScript ensures your methods return what they promise
4. **IntelliSense magic** - Your editor now knows exactly what properties and methods are available!

**Here's a question for you:** Why do you think we used `private`, `protected`, and `public`? What's the difference, and when would you use each?

## Access Modifiers - The Security System for Your Code! üîê

Now let's talk about one of TypeScript's coolest features that JavaScript simply doesn't have: **access modifiers**! These are like security badges for your code properties and methods.

**Here's a scenario for you:** Imagine you're building a bank account system. You definitely don't want random code to directly mess with someone's balance, right? But you might want other banking classes to access some internal methods. How would you handle this?

**That's exactly what access modifiers solve!** Let me show you:

<InteractiveCodeBlock editable={true} language="typescript">
{`class BankAccount {
  // üîí PRIVATE - Fort Knox level security!
  private balance: number;          // Only THIS class can touch this
  private transactionHistory: string[] = [];

  // üõ°Ô∏è PROTECTED - Family members only!  
  protected accountId: string;      // This class + child classes can access
  protected bankName: string = "TypeScript Bank";

  // üåê PUBLIC - Open to the world!
  public owner: string;             // Anyone can access (default behavior)
  public accountType: string;

  constructor(owner: string, accountType: string, initialBalance: number = 0) {
    this.owner = owner;
    this.accountType = accountType;
    this.balance = initialBalance;
    this.accountId = this.generateAccountId();
  }

  // üîí PRIVATE method - internal business logic
  private generateAccountId(): string {
    return \`ACC\${Math.random().toString(36).substr(2, 9)}\`;
  }

  // üîí PRIVATE method - sensitive logging
  private logTransaction(type: string, amount: number): void {
    this.transactionHistory.push(\`\${type}: $\${amount} at \${new Date()}\`);
  }

  // üõ°Ô∏è PROTECTED method - child classes might need this
  protected validateAmount(amount: number): boolean {
    return amount > 0 && amount <= 10000;
  }

  // üõ°Ô∏è PROTECTED method - internal bank operations
  protected getAccountInfo(): string {
    return \`Account \${this.accountId} at \${this.bankName}\`;
  }

  // üåê PUBLIC method - customer interface
  public deposit(amount: number): void {
    if (this.validateAmount(amount)) {
      this.balance += amount;
      this.logTransaction("DEPOSIT", amount);
      console.log(\`üí∞ Deposited $\${amount}. New balance: $\${this.balance}\`);
    } else {
      throw new Error("‚ùå Invalid deposit amount (must be 1-10000)");
    }
  }

  // üåê PUBLIC method - customer interface  
  public getBalance(): number {
    return this.balance;
  }

  // üåê PUBLIC method - customer can see their transactions
  public getTransactionCount(): number {
    return this.transactionHistory.length; // We can access private from inside the class!
  }
}

// üöÄ Let's test the security system!
const myAccount = new BankAccount("Alice", "Checking", 1000);

console.log("=== Testing PUBLIC access ===");
console.log("Owner:", myAccount.owner);          // ‚úÖ Works - public
console.log("Account type:", myAccount.accountType); // ‚úÖ Works - public
console.log("Balance:", myAccount.getBalance()); // ‚úÖ Works - public method

console.log("\\n=== Testing PRIVATE access (these would cause errors!) ===");
// console.log(myAccount.balance);           // ‚ùå Error: Property 'balance' is private
// console.log(myAccount.generateAccountId()); // ‚ùå Error: Method is private
// console.log(myAccount.transactionHistory);  // ‚ùå Error: Property is private

console.log("\\n=== Testing deposits ===");
myAccount.deposit(500);
myAccount.deposit(200);
console.log("Transactions made:", myAccount.getTransactionCount());`}
</InteractiveCodeBlock>

**This is absolutely brilliant!** Let me ask you a few questions to make sure you really get this:

1. **Why do you think `balance` is private instead of public?** 
   - Because we don't want external code directly manipulating someone's money!

2. **Why is `validateAmount` protected instead of private?**
   - Because if we create subclasses (like `SavingsAccount` or `CheckingAccount`), they might need this validation logic too!

3. **What happens if you try to access `myAccount.balance` directly?**
   - TypeScript throws a compile-time error! It won't even let your code run!

**Here's the beautiful part:** This isn't just about preventing access - it's about **designing intention**. When you see `private`, you immediately know "this is internal implementation." When you see `protected`, you think "this is for inheritance." When you see `public`, you know "this is the official API."

**Real-world analogy:** Think of a restaurant:
- **Private** = Kitchen equipment (staff only)
- **Protected** = Staff areas (employees and management)
- **Public** = Dining area (everyone welcome)

The chef (your class) can use all areas, but customers (external code) can only access the public dining area!

## Advanced Class Features

### Constructor Parameter Properties

TypeScript has a shortcut for defining properties in the constructor:

<InteractiveCodeBlock editable={true} language="typescript">
{`class User {
  // üöÄ Super concise! These parameters automatically become class properties
  constructor(
    public name: string,           // Creates public name property
    private email: string,         // Creates private email property  
    protected userId: string = generateId()  // Creates protected property with default
  ) {
    // No need to write this.name = name, etc.!
    console.log(\`User created: \${this.name}\`);
  }

  // Now we can use the properties normally
  getPublicInfo(): string {
    return \`User: \${this.name}\`;
  }

  // Can access private properties from within class
  updateEmail(newEmail: string): void {
    if (this.isValidEmail(newEmail)) {
      this.email = newEmail;
      console.log("Email updated successfully!");
    }
  }

  private isValidEmail(email: string): boolean {
    return email.includes("@");
  }
}

function generateId(): string {
  return "user_" + Math.random().toString(36).substr(2, 9);
}

// üéØ Usage - much cleaner constructor calls!
const user = new User("Alice", "alice@example.com");
console.log(user.getPublicInfo());
user.updateEmail("newalice@example.com");`}
</InteractiveCodeBlock>

### Static Properties and Methods

Sometimes you want properties and methods that belong to the class itself, not instances:

<InteractiveCodeBlock editable={true} language="typescript">
{`class MathUtils {
  // üìä Static properties - belong to the class, not instances
  static readonly PI = 3.14159;
  static readonly E = 2.71828;
  
  // üìà Track how many calculations we've done
  private static calculationCount: number = 0;

  // üßÆ Static methods - can be called without creating an instance
  static calculateCircleArea(radius: number): number {
    this.calculationCount++; // Access static property
    return this.PI * radius * radius;
  }

  static calculateCircumference(radius: number): number {
    this.calculationCount++;
    return 2 * this.PI * radius;
  }

  // üìä Static method to get statistics
  static getCalculationStats(): string {
    return \`Total calculations performed: \${this.calculationCount}\`;
  }

  // üîÑ Instance method for comparison
  multiplyByPI(value: number): number {
    MathUtils.calculationCount++; // Access static from instance method
    return value * MathUtils.PI;
  }
}

// üöÄ Using static methods - no need to create an instance!
console.log("Circle area:", MathUtils.calculateCircleArea(5));
console.log("Circumference:", MathUtils.calculateCircumference(5));
console.log(MathUtils.getCalculationStats());

// üéØ For instance methods, we need an instance
const mathHelper = new MathUtils();
console.log("5 * PI =", mathHelper.multiplyByPI(5));
console.log(MathUtils.getCalculationStats());`}
</InteractiveCodeBlock>

**When to use static vs instance:**
- **Static**: Utility functions, constants, factory methods
- **Instance**: When you need to work with specific object data

## Practical Exercise

Let's build a complete TypeScript class system for a simple task manager:

<InteractiveCodeBlock editable={true} language="typescript">
{`class Task {
  private static nextId: number = 1;
  
  constructor(
    private title: string,
    private description: string,
    public readonly id: number = Task.nextId++,
    private completed: boolean = false,
    private createdAt: Date = new Date()
  ) {}

  // ‚úÖ Mark task as complete
  markCompleted(): void {
    if (this.completed) {
      console.log(\`Task "\${this.title}" is already completed!\`);
      return;
    }
    this.completed = true;
    console.log(\`‚úÖ Task "\${this.title}" marked as completed!\`);
  }

  // üìù Update task details
  updateTask(newTitle?: string, newDescription?: string): void {
    if (this.completed) {
      throw new Error("Cannot update completed task");
    }
    
    if (newTitle) this.title = newTitle;
    if (newDescription) this.description = newDescription;
    
    console.log(\`üìù Task #\${this.id} updated!\`);
  }

  // üìä Get task info
  getInfo(): string {
    const status = this.completed ? "‚úÖ DONE" : "‚è≥ PENDING";
    const age = Math.floor((Date.now() - this.createdAt.getTime()) / (1000 * 60 * 60 * 24));
    return \`[#\${this.id}] \${this.title} - \${status} (Created \${age} days ago)\`;
  }

  // üîç Getters for controlled access
  get isCompleted(): boolean {
    return this.completed;
  }

  get taskTitle(): string {
    return this.title;
  }
}

// üöÄ Let's create a task management system!
class TaskManager {
  private tasks: Task[] = [];

  addTask(title: string, description: string): Task {
    const task = new Task(title, description);
    this.tasks.push(task);
    console.log(\`‚ûï Added task: \${task.getInfo()}\`);
    return task;
  }

  completeTask(id: number): boolean {
    const task = this.tasks.find(t => t.id === id);
    if (task) {
      task.markCompleted();
      return true;
    }
    console.log(\`‚ùå Task #\${id} not found!\`);
    return false;
  }

  listTasks(): void {
    console.log("\\nüìã Current Tasks:");
    if (this.tasks.length === 0) {
      console.log("No tasks yet! Time to add some.");
      return;
    }
    
    this.tasks.forEach(task => {
      console.log(\`  \${task.getInfo()}\`);
    });
  }

  getCompletionRate(): string {
    if (this.tasks.length === 0) return "No tasks to analyze";
    
    const completedTasks = this.tasks.filter(task => task.isCompleted).length;
    const rate = ((completedTasks / this.tasks.length) * 100).toFixed(1);
    return \`Completion Rate: \${rate}% (\${completedTasks}/\${this.tasks.length})\`;
  }
}

// üéØ Let's test our task manager!
const manager = new TaskManager();

const task1 = manager.addTask("Learn TypeScript", "Study TypeScript classes and OOP");
const task2 = manager.addTask("Build a project", "Create a task manager using TypeScript");
const task3 = manager.addTask("Write tests", "Add unit tests for the task manager");

manager.listTasks();

// Complete some tasks
manager.completeTask(1);
manager.completeTask(2);

console.log("\\n" + manager.getCompletionRate());
manager.listTasks();`}
</InteractiveCodeBlock>

## Key Takeaways

1. **Type Safety**: TypeScript classes catch errors at compile-time, not runtime
2. **Access Modifiers**: Use `private`, `protected`, and `public` to control access
3. **Constructor Shortcuts**: Parameter properties save time and reduce boilerplate
4. **Static Members**: Use for class-level data and utility methods
5. **Getters/Setters**: Provide controlled access to private properties

**What's Next?** 

Now that you understand TypeScript classes, you're ready to explore:
- **Interfaces** - Define contracts for your classes
- **Inheritance** - Build class hierarchies 
- **Abstract Classes** - Create templates for other classes
- **Design Patterns** - Common solutions using TypeScript classes

TypeScript classes are the foundation of robust, maintainable object-oriented code. Practice creating your own classes with different access modifiers and features!