---
title: "Object-Oriented Programming with TypeScript"
description: "Master advanced OOP concepts using TypeScript's powerful type system, including classes, interfaces, generics, and design patterns"
difficulty: 3
estimatedTime: "45 minutes"
prerequisites: ["constructor-functions-and-prototypes"]
category: "oop"
---

# Object-Oriented Programming with TypeScript

Hey there, TypeScript explorer! 🚀 Ready to discover what happens when you give JavaScript a serious upgrade? If regular JavaScript OOP was like driving a car, TypeScript is like piloting a spaceship with all the advanced controls, safety systems, and autopilot features you could dream of!

Remember how in our previous tutorials we learned about objects, prototypes, and constructor functions? Well, TypeScript takes ALL of that and says "Hold my coffee, I'm about to make this 10x better!" ☕

**Here's what blew MY mind when I first learned TypeScript:** You get all the power of JavaScript's flexibility, but with a safety net that catches your mistakes BEFORE your code even runs. It's like having a really smart friend who constantly whispers "Hey, are you sure about that?" while you're coding.

## Why TypeScript for OOP? (Spoiler: It's Game-Changing!)

Let me ask you something: **How many times have you written JavaScript and thought "I wish my editor could tell me what properties this object has" or "I hope I'm calling this method with the right arguments"?** 

TypeScript is the answer to those prayers! Here's what makes it absolutely incredible:

- **Type Safety** 🛡️ - Catch typos and errors while you're typing (not when users are crying!)
- **IntelliSense on Steroids** 🧠 - Your editor becomes a mind reader
- **Interfaces** 📋 - Create contracts that your code MUST follow (no more guessing!)
- **Access Modifiers** 🔒 - Control who can touch what (privacy for your code!)
- **Generics** 🎭 - Write code that works with ANY type (but safely!)
- **Real-time Error Detection** ⚡ - Know about problems before your users do!

**The best part?** Everything you learned about JavaScript OOP still applies - TypeScript just makes it bulletproof! 

**Quick question for you:** Have you ever had a bug in production because you passed a string where you meant to pass a number? With TypeScript, that literally can't happen. Intrigued? Let's dive in! 🏊‍♂️

## Classes in TypeScript - JavaScript Classes on Steroids! 💪

Alright, here's where the magic starts! Remember JavaScript classes from our previous tutorials? TypeScript classes are like those, but with superpowers. It's like comparing a regular smartphone to the latest iPhone - same basic concept, but SO much more powerful!

### Basic Class Definition - Let's Build a Smart Person!

**Before we dive into the code, let me ask you:** What do you think is the biggest difference you'll notice between a JavaScript class and a TypeScript class?

Take a guess... 🤔

**The answer:** TYPE ANNOTATIONS! Every property, parameter, and return value gets a type. It's like giving everything a name tag that says "Hi, I'm a string" or "Hi, I'm a number!"

<InteractiveCodeBlock language="typescript">
{`class Person {
  // 🏷️ Property declarations with types (JavaScript can't do this!)
  private name: string;      // Only this class can see this
  protected age: number;     // This class and its children can see this
  public email: string;      // Everyone can see this (same as no modifier)

  // 🔧 Constructor with typed parameters
  constructor(name: string, age: number, email: string) {
    this.name = name;
    this.age = age;
    this.email = email;
  }

  // 🎯 Method with return type annotation
  greet(): string {
    return "Hello, I'm " + this.name;
  }

  // 📖 Getter (computed property)
  get displayName(): string {
    return this.name;
  }

  // ✏️ Setter with validation
  set displayName(value: string) {
    if (value.length < 2) {
      throw new Error("Name must be at least 2 characters");
    }
    this.name = value;
  }

  // 🧮 Let's add a method that shows TypeScript's power
  celebrateBirthday(): string {
    this.age++; // TypeScript KNOWS this is a number!
    return \`🎉 Happy birthday! Now I'm \${this.age} years old.\`;
  }
}

// 🚀 Let's test our TypeScript class!
const alice = new Person("Alice", 25, "alice@example.com");

console.log(alice.greet());
console.log(alice.celebrateBirthday());

// 🔒 Try accessing private property (this will cause an error!)
// console.log(alice.name); // ❌ Error: Property 'name' is private

// ✅ But we can use the getter!
console.log("Display name:", alice.displayName);

// 🛡️ Type safety in action - try passing wrong types!
// const bob = new Person(123, "Bob", true); // ❌ TypeScript catches this!

console.log("Email is accessible:", alice.email); // ✅ Public property works!`}
</InteractiveCodeBlock>

**WHOA! Did you see all that magic happening?** Let me break down what just blew my mind:

1. **`private name: string`** - TypeScript literally won't let you access `alice.name` from outside the class!
2. **Typed parameters** - If you try to pass a number where a string is expected, TypeScript stops you cold
3. **Return type annotations** - TypeScript ensures your methods return what they promise
4. **IntelliSense magic** - Your editor now knows exactly what properties and methods are available!

**Here's a question for you:** Why do you think we used `private`, `protected`, and `public`? What's the difference, and when would you use each?

**Think about it like your house:**
- **`private`** = Your bedroom (only you can enter)
- **`protected`** = Family room (you and your family members)  
- **`public`** = Front yard (everyone can see and access)

**But wait, there's more!** Notice how TypeScript caught our potential errors BEFORE the code even ran? In regular JavaScript, you'd only discover these problems when your app crashes. TypeScript is like having a super-smart proofreader who never sleeps! 🦉

### Access Modifiers - The Security System for Your Code! 🔐

Now let's talk about one of TypeScript's coolest features that JavaScript simply doesn't have: **access modifiers**! These are like security badges for your code properties and methods.

**Here's a scenario for you:** Imagine you're building a bank account system. You definitely don't want random code to directly mess with someone's balance, right? But you might want other banking classes to access some internal methods. How would you handle this?

**That's exactly what access modifiers solve!** Let me show you:

<InteractiveCodeBlock language="typescript">
{`class BankAccount {
  // 🔒 PRIVATE - Fort Knox level security!
  private balance: number;          // Only THIS class can touch this
  private transactionHistory: string[] = [];

  // 🛡️ PROTECTED - Family members only!  
  protected accountId: string;      // This class + child classes can access
  protected bankName: string = "TypeScript Bank";

  // 🌐 PUBLIC - Open to the world!
  public owner: string;             // Anyone can access (default behavior)
  public accountType: string;

  constructor(owner: string, accountType: string, initialBalance: number = 0) {
    this.owner = owner;
    this.accountType = accountType;
    this.balance = initialBalance;
    this.accountId = this.generateAccountId();
  }

  // 🔒 PRIVATE method - internal business logic
  private generateAccountId(): string {
    return \`ACC\${Math.random().toString(36).substr(2, 9)}\`;
  }

  // 🔒 PRIVATE method - sensitive logging
  private logTransaction(type: string, amount: number): void {
    this.transactionHistory.push(\`\${type}: $\${amount} at \${new Date()}\`);
  }

  // 🛡️ PROTECTED method - child classes might need this
  protected validateAmount(amount: number): boolean {
    return amount > 0 && amount <= 10000;
  }

  // 🛡️ PROTECTED method - internal bank operations
  protected getAccountInfo(): string {
    return \`Account \${this.accountId} at \${this.bankName}\`;
  }

  // 🌐 PUBLIC method - customer interface
  public deposit(amount: number): void {
    if (this.validateAmount(amount)) {
      this.balance += amount;
      this.logTransaction("DEPOSIT", amount);
      console.log(\`💰 Deposited $\${amount}. New balance: $\${this.balance}\`);
    } else {
      throw new Error("❌ Invalid deposit amount (must be 1-10000)");
    }
  }

  // 🌐 PUBLIC method - customer interface  
  public getBalance(): number {
    return this.balance;
  }

  // 🌐 PUBLIC method - customer can see their transactions
  public getTransactionCount(): number {
    return this.transactionHistory.length; // We can access private from inside the class!
  }
}

// 🚀 Let's test the security system!
const myAccount = new BankAccount("Alice", "Checking", 1000);

console.log("=== Testing PUBLIC access ===");
console.log("Owner:", myAccount.owner);          // ✅ Works - public
console.log("Account type:", myAccount.accountType); // ✅ Works - public
console.log("Balance:", myAccount.getBalance()); // ✅ Works - public method

console.log("\\n=== Testing PRIVATE access (these would cause errors!) ===");
// console.log(myAccount.balance);           // ❌ Error: Property 'balance' is private
// console.log(myAccount.generateAccountId()); // ❌ Error: Method is private
// console.log(myAccount.transactionHistory);  // ❌ Error: Property is private

console.log("\\n=== Testing deposits ===");
myAccount.deposit(500);
myAccount.deposit(200);
console.log("Transactions made:", myAccount.getTransactionCount());`}
</InteractiveCodeBlock>

**This is absolutely brilliant!** Let me ask you a few questions to make sure you really get this:

1. **Why do you think `balance` is private instead of public?** 
   - Because we don't want external code directly manipulating someone's money!

2. **Why is `validateAmount` protected instead of private?**
   - Because if we create subclasses (like `SavingsAccount` or `CheckingAccount`), they might need this validation logic too!

3. **What happens if you try to access `myAccount.balance` directly?**
   - TypeScript throws a compile-time error! It won't even let your code run!

**Here's the beautiful part:** This isn't just about preventing access - it's about **designing intention**. When you see `private`, you immediately know "this is internal implementation." When you see `protected`, you think "this is for inheritance." When you see `public`, you know "this is the official API."

**Real-world analogy:** Think of a restaurant:
- **Private** = Kitchen equipment (staff only)
- **Protected** = Staff areas (employees and management)
- **Public** = Dining area (everyone welcome)

The chef (your class) can use all areas, but customers (external code) can only access the public dining area!

## Interfaces - The Ultimate Contracts for Your Code! 📜

Here's where TypeScript gets REALLY powerful! **Interfaces are like contracts or blueprints that say "If you want to be this type of thing, you MUST have these properties and methods."**

Think about it like this: **What makes something "flyable"?** It needs to be able to take off, fly, and land, right? **What makes something "swimmable"?** It should be able to dive in, swim around, and surface. 

**That's exactly what interfaces do!** They define the "what" without worrying about the "how."

<InteractiveCodeBlock language="typescript">
{`// 🕊️ Interface for anything that can fly
interface Flyable {
  altitude: number;           // How high are we?
  fly(): void;               // Take to the skies!
  land(): void;              // Come back down safely
}

// 🏊 Interface for anything that can swim  
interface Swimmable {
  depth: number;             // How deep are we?
  swim(): void;              // Get in the water!
  surface(): void;           // Come back up for air
}

// 🦆 A duck can do BOTH! (Multiple interface implementation)
class Duck implements Flyable, Swimmable {
  // ✅ We MUST have all properties from both interfaces
  altitude: number = 0;
  depth: number = 0;
  
  name: string; // We can add our own properties too!
  
  constructor(name: string) {
    this.name = name;
  }

  // ✅ We MUST implement all methods from Flyable
  fly(): void {
    this.altitude = 100;
    console.log(\`🦆 \${this.name} is flying at \${this.altitude} feet!\`);
  }

  land(): void {
    this.altitude = 0;
    console.log(\`🦆 \${this.name} landed safely on the ground.\`);
  }

  // ✅ We MUST implement all methods from Swimmable
  swim(): void {
    this.depth = 5;
    console.log(\`🦆 \${this.name} is swimming \${this.depth} feet underwater!\`);
  }

  surface(): void {
    this.depth = 0;
    console.log(\`🦆 \${this.name} surfaced and is floating happily.\`);
  }

  // 🎵 We can add unique duck methods too!
  quack(): void {
    console.log(\`🦆 \${this.name} says: QUACK QUACK!\`);
  }
}

// 🛩️ What about something that can only fly?
class Airplane implements Flyable {
  altitude: number = 0;
  model: string;
  
  constructor(model: string) {
    this.model = model;
  }
  
  fly(): void {
    this.altitude = 30000;
    console.log(\`✈️ \${this.model} is flying at \${this.altitude} feet!\`);
  }
  
  land(): void {
    this.altitude = 0;
    console.log(\`✈️ \${this.model} landed at the airport.\`);
  }
}

// 🚀 Let's test our interfaces!
const donald = new Duck("Donald");
const boeing = new Airplane("Boeing 747");

console.log("=== Duck Adventures ===");
donald.fly();
donald.swim();
donald.surface();
donald.land();
donald.quack();

console.log("\\n=== Airplane Journey ===");
boeing.fly();
boeing.land();

// 🤔 Here's the cool part - we can treat them the same way!
function makeSomethingFly(flyableObject: Flyable): void {
  flyableObject.fly();
}

console.log("\\n=== Interface Magic ===");
makeSomethingFly(donald);    // Works! Duck implements Flyable
makeSomethingFly(boeing);    // Works! Airplane implements Flyable

// This function accepts ANYTHING that can swim
function makeSomethingSwim(swimmableObject: Swimmable): void {
  swimmableObject.swim();
}

makeSomethingSwim(donald);   // Works! Duck implements Swimmable
// makeSomethingSwim(boeing); // ❌ Error! Airplane doesn't implement Swimmable`}
</InteractiveCodeBlock>

**This is where my mind was BLOWN when I first learned interfaces!** Let me ask you some questions:

1. **What do you think happens if we forget to implement one of the required methods?**
   - TypeScript throws an error! It says "Hey, you promised to implement `swim()` but I don't see it!"

2. **Why can we pass both `donald` and `boeing` to the `makeSomethingFly` function?**
   - Because they both implement the `Flyable` interface! TypeScript knows they both have the required methods.

3. **What's the advantage of this approach?**
   - We can write functions that work with ANY object that implements a specific interface, not just specific classes!

**The magic here is POLYMORPHISM!** The `makeSomethingFly` function doesn't care if you pass it a Duck, Airplane, Bird, or Superhero - as long as it can fly, it works!

**Real-world analogy:** Think of interfaces like job descriptions:
- "We need someone who can drive" (Drivable interface)  
- "We need someone who can code" (Programmable interface)
- "We need someone who can teach" (Teachable interface)

A person could implement ALL of these interfaces - they'd be a coding teacher who can drive to work! 🚗👩‍🏫💻

### Interface for Object Shapes

```typescript
interface User {
  id: number;
  name: string;
  email: string;
  isActive?: boolean; // Optional property
  readonly createdAt: Date; // Read-only property
}

interface UserMethods {
  updateEmail(newEmail: string): void;
  deactivate(): void;
}

// Extending interfaces
interface AdminUser extends User {
  permissions: string[];
  lastLogin?: Date;
}

class UserAccount implements User, UserMethods {
  id: number;
  name: string;
  email: string;
  isActive: boolean = true;
  readonly createdAt: Date;

  constructor(id: number, name: string, email: string) {
    this.id = id;
    this.name = name;
    this.email = email;
    this.createdAt = new Date();
  }

  updateEmail(newEmail: string): void {
    // Email validation logic
    if (this.isValidEmail(newEmail)) {
      this.email = newEmail;
    } else {
      throw new Error("Invalid email format");
    }
  }

  deactivate(): void {
    this.isActive = false;
  }

  private isValidEmail(email: string): boolean {
    return email.includes("@") && email.includes(".");
  }
}
```

## Inheritance in TypeScript - Building a Family Tree! 🌳

Alright, now we're getting into some REALLY cool stuff! **Inheritance is like creating a family tree for your classes.** You have parent classes that pass down their traits to their children, just like in real families!

**But here's where I want to blow your mind:** What if I told you that with TypeScript inheritance, a child class can not only inherit everything from its parent, but also ADD new abilities AND even change how inherited abilities work? 

**Let me show you with an animal kingdom example:**

### Class Inheritance - Let's Build an Animal Family!

**Think about real animals for a second:** All animals share some common traits (they have names, they can move, they make sounds), but each specific type of animal has its own unique characteristics. 

**How do you think we could model this in code?**

<InteractiveCodeBlock language="typescript">
{`// 🦴 The parent class - defines what ALL animals have in common
class Animal {
  protected name: string;       // Protected so children can access it
  protected species: string;    // But outside code cannot
  protected energy: number = 100;

  constructor(name: string, species: string) {
    this.name = name;
    this.species = species;
  }

  // 📢 Basic method that children can override
  makeSound(): string {
    return "Some generic animal sound";
  }

  // 🏃 Movement that all animals share
  move(): string {
    this.energy -= 10;
    return \`\${this.name} is moving (Energy: \${this.energy})\`;
  }

  // 📝 Description that can be enhanced by children
  describe(): string {
    return \`\${this.name} is a \${this.species}\`;
  }

  // 😴 Rest to regain energy
  rest(): string {
    this.energy = Math.min(100, this.energy + 30);
    return \`\${this.name} is resting (Energy: \${this.energy})\`;
  }
}

// 🐕 Dog class - inherits from Animal but adds its own personality!
class Dog extends Animal {
  private breed: string;
  private isGoodBoy: boolean = true; // All dogs are good boys/girls!

  constructor(name: string, breed: string) {
    super(name, "Canine"); // 🔥 Call parent constructor with "Canine"
    this.breed = breed;
  }

  // 🔊 Override parent method - dogs bark!
  makeSound(): string {
    return "Woof! Woof!";
  }

  // ✨ Enhance parent description with breed info
  describe(): string {
    return \`\${super.describe()} and is a \${this.breed}\`; // super = parent's version
  }

  // 🎾 New method specific to dogs
  fetch(): string {
    if (this.energy < 20) {
      return \`\${this.name} is too tired to fetch. Maybe later?\`;
    }
    this.energy -= 20;
    return \`\${this.name} is fetching the ball! So fun! (Energy: \${this.energy})\`;
  }

  // 🐕 Another dog-specific method
  wagTail(): string {
    return \`\${this.name} is wagging their tail happily!\`;
  }
}

// 🐱 Cat class - also inherits from Animal but very different personality!
class Cat extends Animal {
  private isIndoor: boolean;
  private attitude: string = "independent"; // Cats gonna cat

  constructor(name: string, isIndoor: boolean = true) {
    super(name, "Feline"); // Call parent with "Feline"
    this.isIndoor = isIndoor;
  }

  // 😸 Cats meow (override)
  makeSound(): string {
    return "Meow!";
  }

  // 🧗 Cats are excellent climbers
  climb(): string {
    if (this.energy < 15) {
      return \`\${this.name} looks at the tree but decides to nap instead.\`;
    }
    this.energy -= 15;
    return \`\${this.name} is gracefully climbing (Energy: \${this.energy})\`;
  }

  // 😴 Cats love to nap (override rest to be more effective)
  rest(): string {
    this.energy = 100; // Cats are nap masters!
    return \`\${this.name} found a sunny spot and is napping blissfully (Energy: Full)\`;
  }

  // 🐾 Cat-specific behavior
  purr(): string {
    return \`\${this.name} is purring contentedly\`;
  }
}

// 🚀 Let's test our animal family!
const buddy = new Dog("Buddy", "Golden Retriever");
const whiskers = new Cat("Whiskers", true);

console.log("=== Meet our animals ===");
console.log(buddy.describe());
console.log(whiskers.describe());

console.log("\\n=== Animal sounds ===");
console.log(\`\${buddy.name}: \${buddy.makeSound()}\`);
console.log(\`\${whiskers.name}: \${whiskers.makeSound()}\`);

console.log("\\n=== Movement and activities ===");
console.log(buddy.move());
console.log(buddy.fetch());
console.log(buddy.wagTail());

console.log(whiskers.move());
console.log(whiskers.climb());
console.log(whiskers.purr());

console.log("\\n=== Recovery time ===");
console.log(buddy.rest());
console.log(whiskers.rest()); // Notice cats rest differently!

console.log("\\n=== The magic of inheritance ===");
// Both are animals, so we can treat them the same way!
const animals: Animal[] = [buddy, whiskers];
animals.forEach(animal => {
  console.log(animal.makeSound()); // Each makes their own sound!
});`}
</InteractiveCodeBlock>

**WHOA! Did you catch all the magic happening there?** Let me quiz you to make sure you're following:

1. **What does `super(name, "Canine")` do in the Dog constructor?**
   - It calls the parent Animal constructor with the dog's name and "Canine" as the species!

2. **Why can Dog and Cat classes access `this.name` but external code cannot?**
   - Because `name` is `protected` - children can see it, but strangers cannot!

3. **What's the difference between `super.describe()` and just `describe()` in the Dog class?**
   - `super.describe()` calls the parent's version, while `describe()` would call the current (Dog's) version!

4. **Why does the Cat's `rest()` method work differently than the Dog's?**
   - Because Cat overrode the `rest()` method to make cats better at napping (which is totally realistic!)

**The beautiful thing about inheritance:** Both Dog and Cat ARE animals, so they can do anything an animal can do, but they also have their own special abilities! It's like having a universal remote that works for all TVs, but each TV might have some unique features too! 📺✨

## Abstract Classes - The Ultimate Blueprints! 📐

**Here's where TypeScript gets REALLY interesting!** Abstract classes are like saying "I know what all vehicles should be able to do, but I can't make a generic vehicle - you HAVE to make a specific type!"

**Think about it:** Can you build a generic "vehicle"? Not really! You build cars, motorcycles, boats, planes... but never just a "vehicle." That's exactly what abstract classes capture!

**The key insight:** Abstract classes let you define the template and some common functionality, but force child classes to implement the specific details.

<InteractiveCodeBlock language="typescript">
{`// 🏗️ Abstract class - the ultimate blueprint!
abstract class Vehicle {
  protected brand: string;
  protected year: number;
  protected isRunning: boolean = false;

  constructor(brand: string, year: number) {
    this.brand = brand;
    this.year = year;
  }

  // ✅ CONCRETE method - all vehicles can use this
  getInfo(): string {
    return \`\${this.year} \${this.brand}\`;
  }

  // ✅ CONCRETE method - common functionality  
  getAge(): number {
    return new Date().getFullYear() - this.year;
  }

  // 🔨 ABSTRACT methods - children MUST implement these!
  abstract start(): string;        // Every vehicle starts differently
  abstract stop(): string;         // Every vehicle stops differently  
  abstract getMaxSpeed(): number;  // Every vehicle has different limits
  abstract getFuelType(): string;  // Different fuel types

  // ✅ CONCRETE method that uses abstract methods
  performStartupSequence(): string[] {
    const sequence = [
      \`Checking \${this.getInfo()}...\`,
      \`Fuel type: \${this.getFuelType()}\`,
      this.start(),
      \`Max speed: \${this.getMaxSpeed()} km/h\`,
      \`Ready to go!\`
    ];
    this.isRunning = true;
    return sequence;
  }
}

// 🚗 Car implementation - must implement all abstract methods!
class Car extends Vehicle {
  private engineType: string;
  private doors: number;

  constructor(brand: string, year: number, engineType: string, doors: number = 4) {
    super(brand, year);
    this.engineType = engineType;
    this.doors = doors;
  }

  // ✅ Must implement - car-specific starting
  start(): string {
    return \`🚗 \${this.brand} car engine started (\${this.engineType})\`;
  }

  // ✅ Must implement - car-specific stopping
  stop(): string {
    this.isRunning = false;
    return \`🚗 \${this.brand} car engine stopped\`;
  }

  // ✅ Must implement - car speed limits
  getMaxSpeed(): number {
    return this.engineType.includes("V8") ? 220 : 180; // V8s are faster!
  }

  // ✅ Must implement - car fuel type
  getFuelType(): string {
    return this.engineType.includes("Electric") ? "Electric" : "Gasoline";
  }

  // 🚪 Car-specific method
  openDoors(): string {
    return \`Opening all \${this.doors} doors\`;
  }
}

// 🏍️ Motorcycle implementation - different implementations!
class Motorcycle extends Vehicle {
  private engineSize: number;
  private hasWindshield: boolean;

  constructor(brand: string, year: number, engineSize: number, hasWindshield: boolean = false) {
    super(brand, year);
    this.engineSize = engineSize;
    this.hasWindshield = hasWindshield;
  }

  // ✅ Must implement - motorcycle-specific starting
  start(): string {
    return \`🏍️ \${this.brand} motorcycle roared to life (\${this.engineSize}cc)\`;
  }

  // ✅ Must implement - motorcycle-specific stopping  
  stop(): string {
    this.isRunning = false;
    return \`🏍️ \${this.brand} motorcycle engine shut down\`;
  }

  // ✅ Must implement - motorcycles are fast!
  getMaxSpeed(): number {
    return this.engineSize > 600 ? 250 : 180; // Big engines = more speed
  }

  // ✅ Must implement - motorcycle fuel
  getFuelType(): string {
    return "Gasoline";
  }

  // 🏍️ Motorcycle-specific method
  wheelie(): string {
    if (!this.isRunning) {
      return "Can't do a wheelie - engine is off!";
    }
    return \`🏍️ \${this.brand} motorcycle doing an epic wheelie!\`;
  }
}

// 🚀 Let's test our abstract class system!
// const genericVehicle = new Vehicle("Generic", 2023); // ❌ Error! Can't instantiate abstract class

const myCar = new Car("Tesla", 2023, "Electric", 4);
const myBike = new Motorcycle("Kawasaki", 2022, 650, true);

console.log("=== Car startup sequence ===");
myCar.performStartupSequence().forEach(step => console.log(step));
console.log(myCar.openDoors());

console.log("\\n=== Motorcycle startup sequence ===");  
myBike.performStartupSequence().forEach(step => console.log(step));
console.log(myBike.wheelie());

console.log("\\n=== Stopping vehicles ===");
console.log(myCar.stop());
console.log(myBike.stop());
console.log(myBike.wheelie()); // Try wheelie when stopped

console.log("\\n=== Vehicle ages ===");
console.log(\`Car age: \${myCar.getAge()} years\`);
console.log(\`Bike age: \${myBike.getAge()} years\`);`}
</InteractiveCodeBlock>

**This is absolutely BRILLIANT!** Let me ask you some questions to make sure you understand the power here:

1. **Why can't we do `new Vehicle("Generic", 2023)`?**
   - Because Vehicle is abstract! TypeScript says "Nope, you must create a specific type of vehicle!"

2. **Notice how `performStartupSequence()` works in the abstract class - what's special about it?**
   - It's a concrete method that calls abstract methods! It provides the structure, but each child class fills in the details!

3. **What happens if we create a Car class but forget to implement `start()`?**
   - TypeScript throws an error: "You promised to implement start() but I don't see it!"

**The magic of abstract classes:**
- **Forces consistency** - All vehicles MUST have start/stop/getMaxSpeed methods
- **Provides shared code** - Common methods like `getInfo()` and `performStartupSequence()`  
- **Prevents mistakes** - Can't accidentally create a generic "Vehicle"
- **Guarantees interface** - You know ANY vehicle will have ALL the required methods

**Real-world analogy:** Think of abstract classes like a job description that says "We need a software engineer" but you can't hire a generic "software engineer" - you hire a Frontend Developer, Backend Developer, or Full-Stack Developer. Each has the basic engineering skills, but specializes in specific areas! 👩‍💻👨‍💻

## Generics in OOP

Generics allow you to create reusable, type-safe classes:

```typescript
// Generic class
class Stack<T> {
  private items: T[] = [];

  push(item: T): void {
    this.items.push(item);
  }

  pop(): T | undefined {
    return this.items.pop();
  }

  peek(): T | undefined {
    return this.items[this.items.length - 1];
  }

  isEmpty(): boolean {
    return this.items.length === 0;
  }

  size(): number {
    return this.items.length;
  }

  toArray(): T[] {
    return [...this.items];
  }
}

// Usage with different types
const numberStack = new Stack<number>();
numberStack.push(1);
numberStack.push(2);
console.log(numberStack.pop()); // 2

const stringStack = new Stack<string>();
stringStack.push("hello");
stringStack.push("world");
console.log(stringStack.peek()); // "world"

// Generic interface
interface Repository<T> {
  create(item: T): void;
  findById(id: string): T | undefined;
  update(id: string, item: T): void;
  delete(id: string): void;
  findAll(): T[];
}

// Implementation with specific type
class UserRepository implements Repository<User> {
  private users: Map<string, User> = new Map();

  create(user: User): void {
    this.users.set(user.id.toString(), user);
  }

  findById(id: string): User | undefined {
    return this.users.get(id);
  }

  update(id: string, user: User): void {
    if (this.users.has(id)) {
      this.users.set(id, user);
    }
  }

  delete(id: string): void {
    this.users.delete(id);
  }

  findAll(): User[] {
    return Array.from(this.users.values());
  }
}
```

## Design Patterns in TypeScript

### Singleton Pattern

```typescript
class DatabaseConnection {
  private static instance: DatabaseConnection;
  private connectionString: string;
  private isConnected: boolean = false;

  private constructor() {
    this.connectionString = "database://localhost:5432/myapp";
  }

  public static getInstance(): DatabaseConnection {
    if (!DatabaseConnection.instance) {
      DatabaseConnection.instance = new DatabaseConnection();
    }
    return DatabaseConnection.instance;
  }

  connect(): void {
    if (!this.isConnected) {
      console.log(`Connecting to ${this.connectionString}`);
      this.isConnected = true;
    }
  }

  disconnect(): void {
    if (this.isConnected) {
      console.log("Disconnecting from database");
      this.isConnected = false;
    }
  }

  query(sql: string): any[] {
    if (!this.isConnected) {
      throw new Error("Not connected to database");
    }
    console.log(`Executing query: ${sql}`);
    return []; // Mock result
  }
}

// Usage
const db1 = DatabaseConnection.getInstance();
const db2 = DatabaseConnection.getInstance();
console.log(db1 === db2); // true - same instance
```

### Factory Pattern

```typescript
interface Shape {
  draw(): string;
  calculateArea(): number;
}

class Circle implements Shape {
  constructor(private radius: number) {}

  draw(): string {
    return `Drawing a circle with radius ${this.radius}`;
  }

  calculateArea(): number {
    return Math.PI * this.radius * this.radius;
  }
}

class Rectangle implements Shape {
  constructor(private width: number, private height: number) {}

  draw(): string {
    return `Drawing a rectangle ${this.width}x${this.height}`;
  }

  calculateArea(): number {
    return this.width * this.height;
  }
}

class Triangle implements Shape {
  constructor(private base: number, private height: number) {}

  draw(): string {
    return `Drawing a triangle with base ${this.base} and height ${this.height}`;
  }

  calculateArea(): number {
    return (this.base * this.height) / 2;
  }
}

// Factory class
class ShapeFactory {
  static createShape(type: string, ...args: number[]): Shape {
    switch (type.toLowerCase()) {
      case 'circle':
        if (args.length !== 1) throw new Error("Circle requires 1 argument: radius");
        return new Circle(args[0]);
      
      case 'rectangle':
        if (args.length !== 2) throw new Error("Rectangle requires 2 arguments: width, height");
        return new Rectangle(args[0], args[1]);
      
      case 'triangle':
        if (args.length !== 2) throw new Error("Triangle requires 2 arguments: base, height");
        return new Triangle(args[0], args[1]);
      
      default:
        throw new Error(`Unknown shape type: ${type}`);
    }
  }
}

// Usage
const circle = ShapeFactory.createShape('circle', 5);
const rectangle = ShapeFactory.createShape('rectangle', 10, 20);
const triangle = ShapeFactory.createShape('triangle', 8, 12);

console.log(circle.draw());
console.log(`Area: ${circle.calculateArea()}`);
```

### Observer Pattern

```typescript
interface Observer {
  update(data: any): void;
}

interface Subject {
  attach(observer: Observer): void;
  detach(observer: Observer): void;
  notify(data: any): void;
}

class NewsPublisher implements Subject {
  private observers: Observer[] = [];
  private latestNews: string = "";

  attach(observer: Observer): void {
    this.observers.push(observer);
  }

  detach(observer: Observer): void {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }

  notify(data: any): void {
    this.observers.forEach(observer => observer.update(data));
  }

  publishNews(news: string): void {
    this.latestNews = news;
    this.notify({
      type: 'news',
      content: news,
      timestamp: new Date()
    });
  }
}

class NewsSubscriber implements Observer {
  constructor(private name: string) {}

  update(data: any): void {
    console.log(`${this.name} received news: ${data.content}`);
  }
}

// Usage
const publisher = new NewsPublisher();
const subscriber1 = new NewsSubscriber("Alice");
const subscriber2 = new NewsSubscriber("Bob");

publisher.attach(subscriber1);
publisher.attach(subscriber2);

publisher.publishNews("Breaking: TypeScript 5.0 released!");
```

## Type Guards and Advanced Types

TypeScript provides powerful type checking capabilities:

```typescript
// Union types
type Status = "loading" | "success" | "error";

interface LoadingState {
  status: "loading";
}

interface SuccessState {
  status: "success";
  data: any;
}

interface ErrorState {
  status: "error";
  message: string;
}

type AppState = LoadingState | SuccessState | ErrorState;

// Type guard functions
function isSuccessState(state: AppState): state is SuccessState {
  return state.status === "success";
}

function isErrorState(state: AppState): state is ErrorState {
  return state.status === "error";
}

// Using type guards
function handleAppState(state: AppState): string {
  if (isSuccessState(state)) {
    return `Data loaded: ${JSON.stringify(state.data)}`;
  } else if (isErrorState(state)) {
    return `Error: ${state.message}`;
  } else {
    return "Loading...";
  }
}
```

## Practical Exercise

Let's build a complete TypeScript OOP system for a library management system:

```typescript
// Abstract base class
abstract class LibraryItem {
  protected id: string;
  protected title: string;
  protected author: string;
  protected isAvailable: boolean = true;

  constructor(id: string, title: string, author: string) {
    this.id = id;
    this.title = title;
    this.author = author;
  }

  abstract getItemType(): string;
  abstract calculateLateFee(daysLate: number): number;

  checkout(): boolean {
    if (this.isAvailable) {
      this.isAvailable = false;
      return true;
    }
    return false;
  }

  returnItem(): void {
    this.isAvailable = true;
  }

  getInfo(): string {
    return `${this.getItemType()}: ${this.title} by ${this.author}`;
  }
}

// Concrete implementations
class Book extends LibraryItem {
  private genre: string;
  private pageCount: number;

  constructor(id: string, title: string, author: string, genre: string, pageCount: number) {
    super(id, title, author);
    this.genre = genre;
    this.pageCount = pageCount;
  }

  getItemType(): string {
    return "Book";
  }

  calculateLateFee(daysLate: number): number {
    return daysLate * 0.50; // $0.50 per day
  }
}

class DVD extends LibraryItem {
  private duration: number; // in minutes

  constructor(id: string, title: string, director: string, duration: number) {
    super(id, title, director);
    this.duration = duration;
  }

  getItemType(): string {
    return "DVD";
  }

  calculateLateFee(daysLate: number): number {
    return daysLate * 1.00; // $1.00 per day
  }
}

// Interface for library operations
interface LibraryOperations {
  addItem(item: LibraryItem): void;
  removeItem(id: string): boolean;
  findItem(id: string): LibraryItem | undefined;
  checkoutItem(id: string): boolean;
  returnItem(id: string): boolean;
}

// Library management system
class Library implements LibraryOperations {
  private items: Map<string, LibraryItem> = new Map();
  private static instance: Library;

  private constructor() {}

  static getInstance(): Library {
    if (!Library.instance) {
      Library.instance = new Library();
    }
    return Library.instance;
  }

  addItem(item: LibraryItem): void {
    this.items.set(item['id'], item);
    console.log(`Added: ${item.getInfo()}`);
  }

  removeItem(id: string): boolean {
    const removed = this.items.delete(id);
    if (removed) {
      console.log(`Removed item with ID: ${id}`);
    }
    return removed;
  }

  findItem(id: string): LibraryItem | undefined {
    return this.items.get(id);
  }

  checkoutItem(id: string): boolean {
    const item = this.findItem(id);
    if (item) {
      const success = item.checkout();
      if (success) {
        console.log(`Checked out: ${item.getInfo()}`);
      } else {
        console.log(`Item not available: ${item.getInfo()}`);
      }
      return success;
    }
    console.log(`Item not found: ${id}`);
    return false;
  }

  returnItem(id: string): boolean {
    const item = this.findItem(id);
    if (item) {
      item.returnItem();
      console.log(`Returned: ${item.getInfo()}`);
      return true;
    }
    console.log(`Item not found: ${id}`);
    return false;
  }

  getAllItems(): LibraryItem[] {
    return Array.from(this.items.values());
  }
}

// Usage example
const library = Library.getInstance();

const book1 = new Book("B001", "The TypeScript Handbook", "Microsoft", "Programming", 300);
const book2 = new Book("B002", "Clean Code", "Robert Martin", "Programming", 464);
const dvd1 = new DVD("D001", "The Matrix", "Wachowski Sisters", 136);

library.addItem(book1);
library.addItem(book2);
library.addItem(dvd1);

library.checkoutItem("B001");
library.checkoutItem("B001"); // Should fail - already checked out
library.returnItem("B001");
```

## Key Takeaways

1. **Type Safety**: TypeScript's type system catches errors early and improves code reliability
2. **Better OOP**: Access modifiers, interfaces, and abstract classes provide better structure
3. **Generics**: Enable type-safe, reusable components
4. **Design Patterns**: TypeScript makes implementing common patterns more robust
5. **Interface Segregation**: Use interfaces to define clear contracts
6. **Inheritance**: Extend functionality while maintaining type safety

TypeScript's OOP features help you build more maintainable, scalable, and bug-free applications. The type system guides development and catches errors before they reach production.

Try implementing your own TypeScript classes with interfaces, generics, and design patterns to master these concepts!