---
title: "JavaScript Modules - Import, Export & Organization"
description: "Learn how to organize JavaScript code with ES6 modules, import/export statements, and modern module patterns"
level: "beginner"
estimatedTime: "20 minutes"
topics: ["Modules", "Import", "Export", "ES6", "Code Organization", "Module Patterns"]
quizQuestions: 6
order: 8
---

# JavaScript Modules - Import, Export & Organization

**Welcome to the architect's masterclass!** ğŸ—ï¸

**Picture this**: You're building the next TikTok. You have user authentication, video uploading, comment systems, notifications, analytics... If you put ALL that code in one giant file, what would happen?

**Chaos!** ğŸ”¥ Thousands of functions with naming conflicts, impossible debugging, and a codebase so tangled that adding a simple feature breaks everything.

**Here's the professional developer secret**: Every app you love - Instagram, Discord, Netflix - they're all built with **modules**. Thousands of small, focused files that work together like a well-orchestrated symphony! ğŸµ

## What are Modules? (Your Code's Best Friends!)

**Think of modules like LEGO blocks** ğŸ§± - each piece has a specific purpose, they connect perfectly together, and you can reuse them to build amazing things!

**Real-world analogy**: Imagine if your smartphone was one giant circuit board instead of separate components (camera module, battery module, screen module). Replacing the camera would mean replacing the entire phone! ğŸ˜±

**Modules solve the same problem in code**:
- **Authentication module**: Handles login/logout
- **API module**: Manages server communication  
- **UI module**: Handles interface components
- **Utils module**: Contains helpful utility functions

**Ready to think like a software architect?** Let's build some digital skyscrapers! ğŸ™ï¸

{/* prettier-ignore-start */}
<InteractiveCodeBlock 
  title="ğŸ¯ The Great Module Challenge" 
  description="ğŸ¤” PREDICTION: What happens when code gets messy? Let's find out!"
  initialCode={`// ğŸš¨ THE CHAOS SIMULATOR: What happens without modules?

console.log("=== Welcome to Chaos Inc. (No Modules) ===");

// ğŸ¤” PREDICTION CHALLENGE: What will happen here?
function calculateArea(width, height) {
  console.log("ğŸ“ Rectangle calculator called");
  return width * height;
}

// ğŸ¯ PLOT TWIST: Another developer adds this function...
function calculateArea(radius) {  // Same name - CONFLICT!
  console.log("â­• Circle calculator called");
  return Math.PI * radius * radius;
}

console.log("\\nğŸ§ª EXPERIMENT 1: Name Collision Disaster");
console.log("ğŸ¤” PREDICT: When I call calculateArea(5, 3), which function runs?");
console.log("A) Rectangle function  B) Circle function  C) Both  D) Error");

let result = calculateArea(5, 3); // What do YOU think will happen?
console.log("ğŸ“Š RESULT:", result);
console.log("ğŸ’€ The last defined function WINS! Rectangle function is gone!");

console.log("\\n=== Real-World Disaster Simulation ===");
console.log("ğŸ¢ Imagine this in a company with 50 developers...");

// Different teams defining similar functions
function formatDate(date) { return date.toDateString(); }        // Team A
function formatDate(date) { return date.toLocaleDateString(); }  // Team B - overwrites!
function sendEmail(to, msg) { console.log(\`Email to \${to}: \${msg}\`); }     // Team C
function sendEmail(to, subject, body) { console.log("Advanced email"); }       // Team D - overwrites!

console.log("ğŸ“… Date formatting:", formatDate(new Date()));
console.log("ğŸ“§ Email result:", sendEmail("user@email.com", "Hello"));
console.log("ğŸ’¡ Notice: Only the LAST versions of functions work!");

console.log("\\n=== THE MODULE SOLUTION ===");
console.log("âœ¨ Let's see how modules fix this nightmare...");

// ğŸ—ï¸ WITH MODULES: Clean, organized, no conflicts!
const GeometryUtils = {
  rectangle: {
    area: (w, h) => {
      console.log("âœ… Rectangle module: calculating area");
      return w * h;
    },
    perimeter: (w, h) => 2 * (w + h)
  },
  circle: {
    area: (r) => {
      console.log("âœ… Circle module: calculating area");
      return Math.PI * r * r;
    },
    circumference: (r) => 2 * Math.PI * r
  }
};

const DateUtils = {
  formatShort: (date) => date.toDateString(),
  formatLong: (date) => date.toLocaleDateString()
};

const EmailService = {
  sendSimple: (to, msg) => console.log(\`ğŸ“§ Simple: \${to} - \${msg}\`),
  sendAdvanced: (to, subject, body) => console.log(\`ğŸ“¨ Advanced: \${to} - \${subject}\`)
};

console.log("\\nğŸ‰ MODULE MAGIC IN ACTION:");
console.log("Rectangle area:", GeometryUtils.rectangle.area(5, 3));
console.log("Circle area:", GeometryUtils.circle.area(3).toFixed(2));
console.log("Date formats:", DateUtils.formatShort(new Date()));
EmailService.sendSimple("user@email.com", "Hello from modules!");

console.log("\\nğŸ§  MINDBLOWN MOMENT:");
console.log("ğŸ’¡ Notice: NO conflicts, CLEAR namespacing, ORGANIZED code!");
console.log("ğŸš€ This is why every professional app uses modules!");

// ğŸ¯ YOUR TURN: Can you imagine managing Instagram's codebase without modules?
console.log("\\nğŸ¤” THINK ABOUT IT:");
console.log("Instagram probably has modules for:");
console.log("- PhotoModule (filters, cropping, uploading)");
console.log("- UserModule (profiles, authentication, followers)");
console.log("- FeedModule (timeline, recommendations, stories)");
console.log("- NotificationModule (likes, comments, mentions)");
console.log("- And hundreds more!");`}
/>
{/* prettier-ignore-end */}

**ğŸ“ What You Just Discovered:**

This simulation shows you the **real nightmare** that happens without modules! When multiple developers work on the same codebase without proper organization:

- **Name collisions destroy functionality** - The last defined function "wins" and overwrites previous ones
- **No way to organize code by responsibility** - Everything is mixed together in chaos
- **Impossible to track what code does what** - Finding bugs becomes a nightmare
- **No reusability** - Copy-paste code everywhere leads to maintenance hell

**ğŸ”¥ The Module Solution:**
- **Namespace separation** - `GeometryUtils.rectangle.area()` vs `GeometryUtils.circle.area()`
- **Clear organization** - Each module has one responsibility
- **No conflicts** - Multiple teams can work simultaneously without overwriting each other's functions
- **Professional scalability** - This is exactly how Instagram organizes code for billions of users!

**ğŸ’¡ Pro Insight:** Every major app you use (Netflix, Uber, Instagram) would be **impossible** to build and maintain without this modular approach. You just learned the foundation of professional software architecture!

---

## ğŸ¯ Learning Checkpoint: Code Organization Mastery!

**Before we dive into syntax, let's test your understanding:**

**ğŸ¤” PREDICTION CHALLENGE**: You're building Netflix. Which of these would be better organized?

**Option A**: One giant file with 50,000 lines containing user login, video streaming, recommendations, billing, and search?

**Option B**: Separate modules like UserModule, VideoModule, RecommendationModule, BillingModule, SearchModule?

**Think about it...** Which would be easier to:
- Debug when something breaks? ğŸ›
- Add new features to? âœ¨
- Have multiple developers work on? ğŸ‘¥
- Test individually? ğŸ§ª

**The answer**: Option B! And that's exactly what we're going to learn now! ğŸš€

---

## 1. Basic Export Syntax - Your Code's Superpowers! ğŸ’ª

**ğŸ¯ MINDSET SHIFT**: Think of exports like giving other developers "access cards" to your code! You decide what they can use and what stays private.

**Two main ways to export**: **named exports** (multiple access cards) and **default exports** (one golden master key).

{/* prettier-ignore-start */}
<InteractiveCodeBlock 
  title="ğŸ¯ Export Mastery Challenge" 
  description="ğŸ¤” PREDICTION: Which export pattern would you choose for different scenarios?"
  initialCode={`console.log("=== THE EXPORT CHALLENGE ===");
console.log("ğŸª Welcome to the Code Marketplace!");

// ğŸ¯ SCENARIO 1: You're building a restaurant app
console.log("\\nğŸ• RESTAURANT APP SCENARIO:");
console.log("ğŸ¤” PREDICT: Which export pattern fits each case?");

// Case A: Multiple utility functions (calculateTip, formatCurrency, getTax)
console.log("\\nğŸ“‹ Case A: Multiple utility functions");
console.log("Should we use: A) Named exports  B) Default export");

// Let's see NAMED EXPORTS in action!
function calculateTip(bill, percentage) {
  return bill * (percentage / 100);
}

function formatCurrency(amount) {
  return "$" + amount.toFixed(2);
}

function getTax(amount, rate) {
  return amount * rate;
}

const TAX_RATE = 0.08;

// In real module: export { calculateTip, formatCurrency, getTax, TAX_RATE };
console.log("âœ… NAMED EXPORTS let us pick and choose:");
console.log("- Bill: $50.00");
console.log("- Tip (18%):", formatCurrency(calculateTip(50, 18)));
console.log("- Tax:", formatCurrency(getTax(50, TAX_RATE)));
console.log("- Total:", formatCurrency(50 + calculateTip(50, 18) + getTax(50, TAX_RATE)));

console.log("\\nğŸ¯ WHY NAMED EXPORTS HERE?");
console.log("âœ¨ Users can import: import { calculateTip } from './utils'");
console.log("âœ¨ Tree shaking: Only imports what they need = smaller bundles!");

// Case B: One main class/object (Restaurant management system)
console.log("\\nğŸ“‹ Case B: One main restaurant system");
console.log("Should we use: A) Named exports  B) Default export");

// Let's see DEFAULT EXPORT in action!
class RestaurantManager {
  constructor(name) {
    this.name = name;
    this.orders = [];
    this.revenue = 0;
  }
  
  addOrder(order) {
    this.orders.push(order);
    this.revenue += order.total;
    return "Order added: " + order.item;
  }
  
  getStats() {
    return {
      totalOrders: this.orders.length,
      revenue: this.revenue,
      averageOrder: this.orders.length ? (this.revenue / this.orders.length).toFixed(2) : 0
    };
  }
  
  getDailySpecial() {
    const specials = ["Pizza Margherita", "Chicken Alfredo", "Caesar Salad"];
    return specials[Math.floor(Math.random() * specials.length)];
  }
}

// In real module: export default RestaurantManager;
let restaurant = new RestaurantManager("Tony's Pizza");
restaurant.addOrder({item: "Pepperoni Pizza", total: 18.50});
restaurant.addOrder({item: "Garlic Bread", total: 6.99});

console.log("âœ… DEFAULT EXPORT for main functionality:");
console.log("- Restaurant:", restaurant.name);
console.log("- Stats:", JSON.stringify(restaurant.getStats()));
console.log("- Today's special:", restaurant.getDailySpecial());

console.log("\\nğŸ¯ WHY DEFAULT EXPORT HERE?");
console.log("âœ¨ Clean imports: import RestaurantManager from './restaurant'");
console.log("âœ¨ One main thing: The class IS the module's primary purpose!");

console.log("\\n=== THE GOLDEN RULES ===");
console.log("ğŸ”¥ NAMED EXPORTS: Multiple utilities, pick what you need");
console.log("ğŸ”¥ DEFAULT EXPORT: One main thing, the star of the show");
console.log("ğŸ”¥ MIX BOTH: Default + named exports = ultimate flexibility!");

// ğŸ¯ BONUS: Mixing both!
console.log("\\nğŸš€ BONUS: The Best of Both Worlds!");
console.log("// In real module:");
console.log("// export default RestaurantManager;");
console.log("// export { calculateTip, formatCurrency, TAX_RATE };");
console.log("// Users get: import Restaurant, { calculateTip } from './module'");

console.log("\\nğŸ§  NOW YOU THINK LIKE A PRO:");
console.log("ğŸ¤” What would YOU export for a social media app?");
console.log("- User class: DEFAULT (main functionality)");
console.log("- validateEmail, hashPassword: NAMED (utilities)");
console.log("- API_ENDPOINTS: NAMED (constants)");`}
/>
{/* prettier-ignore-end */}

**ğŸ“ Export Mastery Unlocked:**

You just learned the **strategic thinking** behind professional module design! Here's what makes this approach so powerful:

**ğŸ”¥ Named Exports - The Swiss Army Knife:**
- **Use when:** You have multiple related utilities (like restaurant functions)
- **Benefit:** Import only what you need â†’ smaller app bundles
- **Real example:** `import { calculateTip, formatCurrency } from './utils'`
- **Tree shaking magic:** Modern bundlers automatically remove unused exports

**â­ Default Exports - The Main Star:**
- **Use when:** You have one primary class or main functionality
- **Benefit:** Clean, simple import syntax
- **Real example:** `import RestaurantManager from './restaurant'`
- **Professional pattern:** One module, one clear purpose

**ğŸš€ The Best of Both Worlds:**
The most sophisticated modules combine both! Export a main class as default, plus utility functions as named exports. This is exactly how React components are structured!

**ğŸ’¡ Career Insight:** Understanding when to use each pattern separates junior developers from seniors. You're now thinking like a professional architect who considers team collaboration, bundle size, and maintainability!

---

## 2. Import Syntax - Assembling Your Code LEGO! ğŸ§±

**ğŸ¤” CRITICAL THINKING MOMENT**: 
You've exported your code modules (created the LEGO pieces). Now comes the magic question: **How do you assemble them into something amazing?**

**Real-world connection**: Think about your phone's apps. Instagram imports camera modules, Facebook imports messaging modules, Spotify imports audio modules. **Every app is assembled from imported pieces!**

**The import superpower**: You're about to learn how to "teleport" functionality from other files into your current code! ğŸš€

{/* prettier-ignore-start */}
<InteractiveCodeBlock 
  title="ğŸš€ The Import Strategy Challenge" 
  description="ğŸ¤” PREDICTION: You're building Uber. Which import strategy would you choose for each scenario?"
  initialCode={`console.log("=== UBER APP IMPORT CHALLENGE ===");
console.log("ğŸš— Building the next Uber! Let's import smartly!");

console.log("\\nğŸ¯ SCENARIO 1: Importing utilities for ride calculations");
console.log("ğŸ¤” PREDICT: For calculateDistance, formatPrice, validateCoordinates...");
console.log("Should you import: A) Each individually  B) Everything at once  C) As a namespace?");

// Strategy A: NAMED IMPORTS (cherry-picking)
console.log("\\nâœ¨ STRATEGY A: Named Imports (Cherry-Picking)");
console.log("// import { calculateDistance, formatPrice } from './ride-utils.js';");

// Simulating imported functions
function simulateNamedImports() {
  const calculateDistance = (lat1, lon1, lat2, lon2) => {
    // Simplified distance calculation
    return Math.sqrt(Math.pow(lat2 - lat1, 2) + Math.pow(lon2 - lon1, 2)) * 69; // miles
  };
  
  const formatPrice = (distance, ratePerMile) => {
    return "$" + (distance * ratePerMile).toFixed(2);
  };
  
  const validateCoordinates = (lat, lon) => {
    return lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180;
  };
  
  console.log("ğŸš— Calculating ride from airport to downtown:");
  let startLat = 40.7128, startLon = -74.0060; // NYC
  let endLat = 40.7282, endLon = -73.9942;
  
  if (validateCoordinates(startLat, startLon) && validateCoordinates(endLat, endLon)) {
    let distance = calculateDistance(startLat, startLon, endLat, endLon);
    let price = formatPrice(distance, 2.50);
    
    console.log("- Distance:", distance.toFixed(1), "miles");
    console.log("- Estimated fare:", price);
    console.log("âœ… RESULT: Clean, only imported what we needed!");
  }
}

// Strategy B: DEFAULT IMPORT (one main thing)
console.log("\\nâœ¨ STRATEGY B: Default Import (The Main Star)");
console.log("// import RideCalculator from './ride-calculator.js';");

function simulateDefaultImport() {
  class RideCalculator {
    constructor(baseRate = 2.50) {
      this.baseRate = baseRate;
      this.surgePricing = false;
    }
    
    calculateFare(distance, surgeMultiplier = 1) {
      let baseFare = distance * this.baseRate * surgeMultiplier;
      let serviceFee = 2.99;
      return baseFare + serviceFee;
    }
    
    estimateTime(distance) {
      let avgSpeed = 25; // mph in city
      return Math.round((distance / avgSpeed) * 60); // minutes
    }
    
    applySurge(multiplier) {
      this.surgePricing = true;
      return "Surge pricing applied: " + multiplier + "x";
    }
  }
  
  let rideCalc = new RideCalculator();
  console.log("ğŸš— Using the main RideCalculator class:");
  console.log("- Base fare (5 miles):", "$" + rideCalc.calculateFare(5).toFixed(2));
  console.log("- Estimated time:", rideCalc.estimateTime(5), "minutes");
  console.log("- Surge applied:", rideCalc.applySurge(1.8));
  console.log("âœ… RESULT: One import, full functionality!");
}

// Strategy C: WILDCARD IMPORT (namespace)
console.log("\\nâœ¨ STRATEGY C: Wildcard Import (Everything under one roof)");
console.log("// import * as UberUtils from './uber-utils.js';");

function simulateWildcardImport() {
  const UberUtils = {
    ride: {
      calculateDistance: (lat1, lon1, lat2, lon2) => Math.abs(lat2 - lat1) + Math.abs(lon2 - lon1),
      calculateFare: (distance) => distance * 2.50 + 2.99,
      estimateTime: (distance) => Math.round(distance * 2.4) // minutes
    },
    user: {
      validatePhone: (phone) => phone.length === 10,
      formatName: (first, last) => first + " " + last,
      getRating: () => (Math.random() * 2 + 3).toFixed(1) // 3-5 stars
    },
    payment: {
      validateCard: (card) => card.length === 16,
      calculateTip: (fare, percentage) => fare * (percentage / 100),
      processPayment: (amount) => "Charged $" + amount.toFixed(2)
    }
  };
  
  console.log("ğŸš— Using organized namespace:");
  console.log("- Ride fare:", "$" + UberUtils.ride.calculateFare(8).toFixed(2));
  console.log("- User rating:", UberUtils.user.getRating(), "â­");
  console.log("- Payment tip:", "$" + UberUtils.payment.calculateTip(25, 20).toFixed(2));
  console.log("âœ… RESULT: Everything organized, but bigger bundle!");
}

// ğŸ¯ THE STRATEGY SHOWDOWN
console.log("\\n=== THE VERDICT ===");

console.log("ğŸ”¥ NAMED IMPORTS: Perfect for utilities you need");
console.log("   âœ… Tree shaking = smaller apps");
console.log("   âœ… Clear dependencies");
console.log("   âŒ Can get verbose with many imports");

console.log("\\nğŸ”¥ DEFAULT IMPORTS: Perfect for main classes/functions");
console.log("   âœ… Clean, simple imports");
console.log("   âœ… One thing, well-defined purpose");
console.log("   âŒ Only one per module");

console.log("\\nğŸ”¥ WILDCARD IMPORTS: Perfect for utility libraries");
console.log("   âœ… Everything accessible");
console.log("   âœ… Organized namespacing");
console.log("   âŒ Larger bundle size");

console.log("\\nğŸš€ PRO STRATEGY: Mix all three based on context!");

// Run all strategies
simulateNamedImports();
simulateDefaultImport();
simulateWildcardImport();

console.log("\\nğŸ§  YOUR TURN TO THINK:");
console.log("ğŸ¤” For Instagram, what would you import?");
console.log("- Camera functions: import { takePhoto, applyFilter } â† Named");
console.log("- Post class: import Post from './post.js' â† Default");
console.log("- Entire UI library: import * as UI from './ui-lib' â† Wildcard");`}
/>
{/* prettier-ignore-end */}

**ğŸ“ Import Strategy Mastery Achieved:**

You just mastered the **three fundamental import patterns** that power every major application! Here's your strategic guide:

**ğŸ¯ Named Imports (Cherry-Picking) - The Precision Tool:**
- **Perfect for:** Utility functions, specific components you need
- **Performance win:** Only bundles what you import (smaller apps!)
- **Team benefit:** Clear dependencies - other developers see exactly what you use
- **Real example:** Uber's ride calculator imports only `calculateDistance` and `formatPrice`

**ğŸ† Default Imports (The Main Character) - The Simplicity Champion:**
- **Perfect for:** Primary classes, main functionality, React components
- **Clean syntax:** `import Calculator from './calculator'` - beautiful and readable
- **Clear purpose:** One import = one main thing your module needs
- **Professional pattern:** This is how most enterprise libraries are designed

**ğŸŒ Wildcard Imports (The Everything Approach) - The Comprehensive Solution:**
- **Perfect for:** Large utility libraries, organized namespaces
- **Organization win:** Everything under one roof with clear structure
- **Trade-off:** Larger bundles but excellent organization
- **Enterprise use:** UI libraries, comprehensive toolkits

**ğŸ’¡ Professional Decision Framework:**
- **Small, focused functions?** â†’ Named imports
- **One main thing?** â†’ Default import  
- **Large, organized library?** â†’ Wildcard import
- **Mix them strategically** for the best developer experience!

**ğŸš€ Career Level Up:** You now think like a senior developer who considers bundle size, team collaboration, and code maintainability when making import decisions!

---

## ğŸ¯ Learning Checkpoint: Import/Export Mastery!

**ğŸ§  REFLECTION MOMENT**: Before we build real apps, let's make sure you've got this!

**Quick Mental Check:**
1. **Named exports**: When do you use them? *(Multiple related functions/utilities)*
2. **Default exports**: Best for what? *(One main class or primary functionality)*
3. **Cherry-picking imports**: What's the benefit? *(Smaller bundles, tree shaking)*
4. **Wildcard imports**: When are they useful? *(Large utility libraries, organized namespaces)*

**ğŸ¤” SCENARIO CHALLENGE**: 
Your friend says: *"I'll just put everything in one giant file - modules are too complex!"* 

**How would you convince them they're wrong?** Think about:
- Team collaboration ğŸ¤
- Code reusability â™»ï¸
- Debugging nightmares ğŸ›
- App performance ğŸš€

**Ready to see modules save the day in real apps?** Let's build! ğŸ’ª

---

## 3. Real-World Module Examples - Building Production Apps! ğŸ—ï¸

**ğŸ¯ MISSION**: You're now a lead developer! Let's see how the pros organize code in real apps like Airbnb, Shopify, and Twitter.

**What you'll discover**: How modules transform chaotic code into clean, professional applications that scale to millions of users!

{/* prettier-ignore-start */}
<InteractiveCodeBlock 
  title="ğŸ¢ Building Airbnb's Module Architecture" 
  description="ğŸ¤” PREDICTION: How would Airbnb organize millions of listings, users, and bookings?"
  initialCode={`console.log("=== AIRBNB ARCHITECTURE CHALLENGE ===");
console.log("ğŸ  Building the next Airbnb! Let's architect like pros!");

console.log("\\nğŸ¤” THINK LIKE A CTO:");
console.log("With millions of users, properties, and bookings...");
console.log("How do we organize this MASSIVE codebase?");

// ğŸ—ï¸ MODULE 1: USER SERVICE (handles all user operations)
console.log("\\nğŸ—ï¸ USER SERVICE MODULE:");
console.log("// file: services/user-service.js");

const UserService = {
  // Profile management
  validateEmail(email) {
    return email && email.includes("@") && email.includes(".");
  },

  validatePassword(password) {
    return password && password.length >= 8;
  },

  formatUserName(firstName, lastName) {
    return firstName + " " + lastName.charAt(0) + "."; // Privacy!
  },

  generateUserId() {
    return 'airbnb_user_' + Math.random().toString(36).substr(2, 9);
  },

  // Host verification
  validateHost(hostData) {
    return hostData.governmentId && hostData.phoneVerified;
  }
};

// ğŸ—ï¸ MODULE 2: PROPERTY SERVICE (manages listings)
console.log("\\nğŸ—ï¸ PROPERTY SERVICE MODULE:");
console.log("// file: services/property-service.js");

const PropertyService = {
  validateListing(property) {
    const required = ['title', 'description', 'price', 'location', 'photos'];
    return required.every(field => property[field]);
  },

  calculateNightlyRate(basePrice, cleaningFee, serviceFee) {
    return {
      basePrice: basePrice,
      cleaningFee: cleaningFee,
      serviceFee: serviceFee,
      totalPerNight: basePrice + cleaningFee + serviceFee
    };
  },

  searchProperties(filters) {
    console.log("ğŸ” Searching properties with filters:", filters);
    return [
      { id: 1, title: "Cozy Downtown Apartment", price: 89 },
      { id: 2, title: "Beach House with Ocean View", price: 159 },
      { id: 3, title: "Mountain Cabin Retreat", price: 129 }
    ];
  },

  checkAvailability(propertyId, checkIn, checkOut) {
    console.log("ğŸ“… Checking availability for property", propertyId);
    return Math.random() > 0.3; // 70% chance available
  }
};

// ğŸ—ï¸ MODULE 3: BOOKING SERVICE (handles reservations)
console.log("\\nğŸ—ï¸ BOOKING SERVICE MODULE:");
console.log("// file: services/booking-service.js");

const BookingService = {
  calculateTotalCost(propertyId, nights, guests) {
    const property = { basePrice: 100, cleaningFee: 25, serviceFee: 15 };
    const baseTotal = property.basePrice * nights;
    const fees = property.cleaningFee + property.serviceFee;
    const guestFee = guests > 2 ? (guests - 2) * 10 : 0;
    
    return {
      baseTotal: baseTotal,
      cleaningFee: property.cleaningFee,
      serviceFee: property.serviceFee,
      guestFee: guestFee,
      totalCost: baseTotal + fees + guestFee
    };
  },

  createReservation(userId, propertyId, bookingDetails) {
    return {
      id: 'booking_' + Math.random().toString(36).substr(2, 9),
      userId: userId,
      propertyId: propertyId,
      status: 'confirmed',
      confirmationCode: Math.random().toString(36).substr(2, 8).toUpperCase(),
      ...bookingDetails
    };
  },

  sendConfirmationEmail(booking) {
    return "ğŸ“§ Confirmation sent for booking: " + booking.confirmationCode;
  }
};

// ğŸ—ï¸ MODULE 4: PAYMENT SERVICE (secure transactions)
console.log("\\nğŸ—ï¸ PAYMENT SERVICE MODULE:");
console.log("// file: services/payment-service.js");

const PaymentService = {
  validateCard(cardNumber, expiry, cvv) {
    return cardNumber.length >= 15 && expiry && cvv.length === 3;
  },

  processPayment(amount, paymentMethod) {
    console.log("ğŸ’³ Processing payment of $" + amount);
    // Simulate payment processing
    return {
      success: Math.random() > 0.1, // 90% success rate
      transactionId: 'txn_' + Math.random().toString(36).substr(2, 12),
      amount: amount,
      status: 'completed'
    };
  },

  refundBooking(bookingId, amount) {
    console.log("ğŸ’° Processing refund for booking:", bookingId);
    return { refunded: amount, status: 'processed' };
  }
};

// ğŸš€ PUTTING IT ALL TOGETHER: The Airbnb App in Action!
console.log("\\n=== AIRBNB APP SIMULATION ===");
console.log("ğŸ‘¤ New user Sarah wants to book a beach house...");

// Step 1: User registration
let newUser = {
  firstName: "Sarah",
  lastName: "Wilson",
  email: "sarah@email.com",
  password: "beachlovr2023"
};

if (UserService.validateEmail(newUser.email) && UserService.validatePassword(newUser.password)) {
  let userId = UserService.generateUserId();
  console.log("âœ… User created:", UserService.formatUserName(newUser.firstName, newUser.lastName));
  
  // Step 2: Search properties
  let searchResults = PropertyService.searchProperties({
    location: "Miami Beach",
    checkIn: "2023-07-15",
    checkOut: "2023-07-18",
    guests: 2
  });
  
  console.log("ğŸ–ï¸ Found", searchResults.length, "properties");
  
  // Step 3: Check availability and book
  let chosenProperty = searchResults[1]; // Beach house
  let isAvailable = PropertyService.checkAvailability(chosenProperty.id, "2023-07-15", "2023-07-18");
  
  if (isAvailable) {
    console.log("ğŸ  Property available:", chosenProperty.title);
    
    // Step 4: Calculate costs
    let costs = BookingService.calculateTotalCost(chosenProperty.id, 3, 2);
    console.log("ğŸ’° Total cost:", "$" + costs.totalCost);
    
    // Step 5: Process payment
    let payment = PaymentService.processPayment(costs.totalCost, "card");
    
    if (payment.success) {
      // Step 6: Create booking
      let booking = BookingService.createReservation(userId, chosenProperty.id, {
        checkIn: "2023-07-15",
        checkOut: "2023-07-18",
        guests: 2,
        totalPaid: costs.totalCost
      });
      
      console.log("ğŸ‰ BOOKING SUCCESS!");
      console.log("ğŸ“‹ Confirmation:", booking.confirmationCode);
      console.log(BookingService.sendConfirmationEmail(booking));
    } else {
      console.log("âŒ Payment failed. Please try again.");
    }
  } else {
    console.log("ğŸ˜” Property not available for those dates");
  }
}

console.log("\\n=== THE MODULE MAGIC ===");
console.log("ğŸ”¥ NOTICE: Each service handles ONE responsibility!");
console.log("âœ… UserService: User management only");
console.log("âœ… PropertyService: Property operations only");  
console.log("âœ… BookingService: Reservation logic only");
console.log("âœ… PaymentService: Payment processing only");

console.log("\\nğŸš€ BENEFITS:");
console.log("ğŸ‘¥ Different teams can work on each service");
console.log("ğŸ§ª Easy to test each service independently");
console.log("ğŸ”§ Easy to update payment logic without breaking user code");
console.log("ğŸ“ˆ Scalable: Each service can be deployed separately!");

console.log("\\nğŸ§  THIS IS HOW REAL APPS ARE BUILT!");
console.log("Netflix, Uber, Instagram - they ALL use this pattern!");`}
/>
{/* prettier-ignore-end */}

**ğŸ“ Real-World Architecture Mastery:**

You just built a **production-grade service architecture** that mirrors how actual billion-dollar companies organize their code!

**ğŸ† What You Accomplished:**
- **Service separation** - Each module has ONE clear responsibility
- **Data flow management** - Services communicate through clean interfaces  
- **Real-world integration** - Multiple services working together seamlessly
- **Scalable patterns** - Each service can be developed and deployed independently

**ğŸ’¼ Professional Impact:**
- **UserService** â†’ Team A works on authentication and profiles
- **PropertyService** â†’ Team B handles listings and search
- **BookingService** â†’ Team C manages reservations and pricing
- **PaymentService** â†’ Team D handles secure transactions

**ğŸš€ Enterprise Benefits You Created:**
- **Parallel development** - Multiple teams work simultaneously without conflicts
- **Independent testing** - Each service can be tested in isolation
- **Flexible updates** - Change payment logic without touching user management
- **Microservice ready** - Each module can become its own server/API

**ğŸ’¡ Career-Level Insight:** This architectural thinking is what separates junior developers from senior engineers. You're now designing systems that can handle millions of users and scale across multiple teams!

**ğŸŒ Real Impact:** The pattern you just learned powers Airbnb's actual platform that handles 150 million users across 100,000 cities. You've leveled up to enterprise-grade thinking!

---

## 4. Modern Module Patterns

Let's explore some advanced module patterns used in modern JavaScript.

{/* prettier-ignore-start */}
<InteractiveCodeBlock 
  title="Advanced Module Patterns" 
  description="Learn modern patterns like module factories, singletons, and configuration modules"
  initialCode={`// === MODULE FACTORY PATTERN ===
function createLogger(level = 'info') {
  const levels = {
    debug: 0,
    info: 1,
    warn: 2,  
    error: 3
  };
  
  const currentLevel = levels[level] || 1;
  
  return {
    debug(message) {
      if (currentLevel <= 0) console.log(\`[DEBUG] \${message}\`);
    },
    
    info(message) {
      if (currentLevel <= 1) console.log(\`[INFO] \${message}\`);
    },
    
    warn(message) {
      if (currentLevel <= 2) console.log(\`[WARN] \${message}\`);
    },
    
    error(message) {
      if (currentLevel <= 3) console.log(\`[ERROR] \${message}\`);
    }
  };
}

// === SINGLETON PATTERN ===
const DatabaseConnection = (() => {
  let instance = null;
  
  function createConnection() {
    return {
      host: 'localhost',
      port: 5432,
      connected: true,
      
      query(sql) {
        return \`Executing: \${sql}\`;
      },
      
      close() {
        this.connected = false;
        console.log("Database connection closed");
      }
    };
  }
  
  return {
    getInstance() {
      if (!instance) {
        instance = createConnection();
        console.log("New database connection created");
      }
      return instance;
    }
  };
})();

// === CONFIGURATION MODULE ===
const Config = {
  development: {
    apiUrl: 'http://localhost:3000/api',
    debug: true,
    logLevel: 'debug'
  },
  
  production: {
    apiUrl: 'https://api.myapp.com',
    debug: false,
    logLevel: 'error'
  },
  
  getCurrentConfig() {
    const env = 'development'; // Would be process.env.NODE_ENV in real app
    return this[env] || this.development;
  }
};

// === USING THE PATTERNS ===
console.log("--- Module Patterns Demo ---");

// Factory pattern
let debugLogger = createLogger('debug');
let prodLogger = createLogger('error');

console.log("\\n--- Logger Factory ---");
debugLogger.debug("Debug message");  // Shows
debugLogger.info("Info message");    // Shows
prodLogger.debug("Debug message");   // Hidden
prodLogger.error("Error message");   // Shows

// Singleton pattern
console.log("\\n--- Singleton Pattern ---");
let db1 = DatabaseConnection.getInstance();
let db2 = DatabaseConnection.getInstance(); // Same instance!
console.log("Same instance?", db1 === db2);
console.log(db1.query("SELECT * FROM users"));

// Configuration module
console.log("\\n--- Configuration Module ---");
let config = Config.getCurrentConfig();
let logger = createLogger(config.logLevel);
console.log("Current config:", config);
logger.info("App starting with current config");`}
/>
{/* prettier-ignore-end */}

**ğŸ“ Advanced Module Patterns Mastery:**

You just learned **three powerful design patterns** that professional developers use to solve complex application challenges!

**ğŸ­ Factory Pattern - The Code Generator:**
- **Use case:** When you need multiple instances with different configurations (like loggers with different levels)
- **Professional example:** AWS SDK creates different service clients, React creates components with different props
- **Power:** One factory function creates infinite customized instances
- **Real impact:** Netflix uses factories to create different video players for different devices

**ğŸ”’ Singleton Pattern - The One and Only:**
- **Use case:** When you need exactly ONE instance shared across your app (database connections, configuration managers)
- **Professional example:** Database connection pools, app configuration, authentication managers
- **Power:** Guarantees single instance, prevents resource waste
- **Real impact:** Every major app uses singletons for database connections to prevent connection limits

**âš™ï¸ Configuration Pattern - The Environment Manager:**
- **Use case:** Different settings for development, testing, and production environments
- **Professional example:** API endpoints, feature flags, logging levels change based on environment
- **Power:** One configuration module adapts your app to any environment
- **Real impact:** Facebook uses this to gradually roll out features to different user groups

**ğŸ’¡ Enterprise Insight:** These patterns are the **secret sauce** behind scalable applications. They solve problems that appear when your app grows from thousands to millions of users. You're now equipped with the same tools that power Google, Amazon, and Netflix!

---

## 5. Module Best Practices

{/* prettier-ignore-start */}
<InteractiveCodeBlock 
  title="Module Best Practices Guide" 
  description="Learn professional patterns for organizing and structuring modules"
  initialCode={`// === BEST PRACTICE 1: Single Responsibility ===
console.log("--- Best Practice Examples ---");

// âŒ BAD: Module does too many things
const BadModule = {
  // User management
  createUser(userData) { /* ... */ },
  deleteUser(userId) { /* ... */ },
  
  // Email functionality  
  sendEmail(to, subject, body) { /* ... */ },
  validateEmail(email) { /* ... */ },
  
  // Database operations
  saveToDatabase(data) { /* ... */ },
  queryDatabase(sql) { /* ... */ },
  
  // Utility functions
  formatDate(date) { /* ... */ },
  generateId() { /* ... */ }
};

// âœ… GOOD: Each module has one responsibility
const UserService = {
  create(userData) {
    console.log("Creating user:", userData.name);
    return {id: 1, ...userData};
  },
  
  delete(userId) {
    console.log("Deleting user:", userId);
    return true;
  }
};

const EmailService = {
  send(to, subject, body) {
    console.log(\`Sending email to \${to}: \${subject}\`);
    return true;
  },
  
  validate(email) {
    return email.includes("@") && email.includes(".");
  }
};

const DatabaseService = {
  save(data) {
    console.log("Saving to database:", data);
    return {success: true, id: Math.random()};
  },
  
  find(query) {
    console.log("Querying database:", query);
    return [{id: 1, name: "Sample Data"}];
  }
};

// === BEST PRACTICE 2: Clear Interfaces ===
// Export only what you need to expose
const ApiClient = (() => {
  // Private variables and functions
  let baseUrl = 'https://api.example.com';
  let authToken = null;
  
  function makeRequest(endpoint, options) {
    return \`Making request to \${baseUrl}\${endpoint}\`;
  }
  
  // Public interface
  return {
    setAuthToken(token) {
      authToken = token;
      console.log("Auth token set");
    },
    
    get(endpoint) {
      return makeRequest(endpoint, {method: 'GET'});
    },
    
    post(endpoint, data) {
      return makeRequest(endpoint, {method: 'POST', body: data});
    }
    
    // baseUrl and makeRequest are NOT exposed
  };
})();

// === BEST PRACTICE 3: Module Documentation ===
/**
 * Math utilities for common calculations
 * @module MathUtils
 * @version 1.0.0
 */
const MathUtils = {
  /**
   * Calculate the area of a rectangle
   * @param {number} width - The width of the rectangle
   * @param {number} height - The height of the rectangle
   * @returns {number} The area of the rectangle
   */
  rectangleArea(width, height) {
    if (typeof width !== 'number' || typeof height !== 'number') {
      throw new Error('Width and height must be numbers');
    }
    return width * height;
  },
  
  /**
   * Calculate compound interest
   * @param {number} principal - Initial amount
   * @param {number} rate - Annual interest rate (as decimal)
   * @param {number} time - Time in years
   * @returns {number} Final amount after compound interest
   */
  compoundInterest(principal, rate, time) {
    return principal * Math.pow(1 + rate, time);
  }
};

// === DEMONSTRATION ===
console.log("\\n--- Using Well-Designed Modules ---");

// User workflow
let user = UserService.create({name: "Alice", email: "alice@email.com"});
DatabaseService.save(user);
EmailService.send(user.email, "Welcome!", "Welcome to our app!");

// API client
ApiClient.setAuthToken("abc123");
console.log(ApiClient.get("/users"));

// Math utilities with validation
try {
  console.log("Rectangle area:", MathUtils.rectangleArea(5, 3));
  console.log("Compound interest:", MathUtils.compoundInterest(1000, 0.05, 10).toFixed(2));
} catch (error) {
  console.log("Math error:", error.message);
}`}
/>
{/* prettier-ignore-end */}

**ğŸ“ Professional Best Practices Mastery:**

You just learned the **three pillars** of enterprise-grade module design that separate amateur code from production-ready software!

**ğŸ¯ Single Responsibility Principle - The Foundation:**
- **The Problem:** BadModule tries to do everything â†’ impossible to maintain, test, or debug
- **The Solution:** One module = one responsibility (UserService only handles users, EmailService only handles emails)
- **Professional Impact:** Teams can work in parallel, bugs are isolated, features are easier to add
- **Real Example:** Amazon has separate services for payments, shipping, reviews, recommendations

**ğŸ›¡ï¸ Clean Interfaces - The Security Guard:**
- **The Problem:** Exposing internal implementation details creates fragile dependencies
- **The Solution:** Only export what other modules NEED to use (private functions stay private)
- **Professional Impact:** Internal changes don't break other code, APIs are cleaner and more secure
- **Real Example:** React only exposes component methods you need, hides internal rendering logic

**ğŸ“š Documentation & Validation - The Communication Protocol:**
- **The Problem:** Undocumented modules with no input validation cause runtime errors and confusion
- **The Solution:** JSDoc comments + input validation = bulletproof, self-documenting code
- **Professional Impact:** New team members understand modules instantly, bugs are caught early
- **Real Example:** TypeScript libraries use this pattern to provide amazing developer experience

**ğŸ’¡ Career-Level Insight:** These practices are **mandatory** in professional development. They're the difference between code that works on your laptop and code that powers applications serving millions of users. Master these, and you're ready for any enterprise development team!

**ğŸ† You're Now Enterprise-Ready:** Your modules would pass code review at Google, Facebook, or Netflix!

---

## 6. Module Loading in Different Environments

{/* prettier-ignore-start */}
<InteractiveCodeBlock 
  title="Module Systems Overview" 
  description="Understand different module systems: ES6, CommonJS, and how they work"
  initialCode={`console.log("--- Module Systems Overview ---");

// === ES6 MODULES (Modern) ===
console.log("\\n1. ES6 Modules (import/export)");
console.log("   Used in: Modern browsers, Node.js (with .mjs or type: 'module')");
console.log("   Syntax:");
console.log("   // math.js");
console.log("   export const PI = 3.14159;");
console.log("   export function add(a, b) { return a + b; }");
console.log("   export default class Calculator { }");
console.log("");
console.log("   // app.js");
console.log("   import { PI, add } from './math.js';");
console.log("   import Calculator from './math.js';");

// === COMMONJS (Node.js traditional) ===
console.log("\\n2. CommonJS (require/module.exports)");
console.log("   Used in: Node.js (traditional)");
console.log("   Syntax:");
console.log("   // math.js");
console.log("   const PI = 3.14159;");
console.log("   function add(a, b) { return a + b; }");
console.log("   module.exports = { PI, add };");
console.log("");
console.log("   // app.js");
console.log("   const { PI, add } = require('./math.js');");

// === AMD (Legacy) ===
console.log("\\n3. AMD - Asynchronous Module Definition");
console.log("   Used in: Legacy browser applications (RequireJS)");
console.log("   Syntax:");
console.log("   define(['dependency'], function(dep) {");
console.log("     return { /* module exports */ };");
console.log("   });");

// === UMD (Universal) ===
console.log("\\n4. UMD - Universal Module Definition");
console.log("   Used in: Libraries that need to work everywhere");
console.log("   Works with: ES6, CommonJS, AMD, and global variables");

// Simulate what happens in different environments
console.log("\\n--- Environment Simulation ---");

// Browser with ES6 modules
function simulateBrowserES6() {
  console.log("Browser ES6: Static imports resolved at compile time");
  console.log("âœ… Tree shaking possible");
  console.log("âœ… Fast loading with HTTP/2");
}

// Node.js with CommonJS
function simulateNodeCommonJS() {
  console.log("Node.js CommonJS: Dynamic imports resolved at runtime");
  console.log("âœ… Conditional loading possible");
  console.log("âœ… Widely supported");
}

// Modern Node.js with ES6
function simulateNodeES6() {
  console.log("Node.js ES6: Best of both worlds");
  console.log("âœ… Static analysis");
  console.log("âœ… Better optimization");
  console.log("âœ… Consistent with browsers");
}

simulateBrowserES6();
simulateNodeCommonJS();
simulateNodeES6();

console.log("\\n--- Module Resolution Demo ---");

// How modules are resolved
const moduleResolution = {
  relative: "./utils.js",        // Same directory
  absolute: "/src/utils.js",     // From root
  package: "lodash",             // From node_modules
  subpath: "lodash/get"          // Specific function
};

Object.entries(moduleResolution).forEach(([type, path]) => {
  console.log(\`\${type.padEnd(10)}: import something from '\${path}'\`);
});`}
/>
{/* prettier-ignore-end */}

**ğŸ“ Module Systems Expertise Achieved:**

You now understand the **evolutionary history** of JavaScript modules and can work in any environment!

**ğŸ“ˆ The Module Evolution Journey:**
1. **AMD (Legacy)** â†’ Solved browser loading but complex syntax
2. **CommonJS (Node.js)** â†’ Simplified server-side modules but runtime-only
3. **ES6 Modules (Modern)** â†’ Best of both worlds, now the universal standard
4. **UMD (Universal)** â†’ Bridge solution for libraries that need to work everywhere

**ğŸ† Environment Mastery:**
- **ES6 in Browsers:** Static imports, tree shaking, HTTP/2 optimized loading
- **CommonJS in Node.js:** Dynamic imports, conditional loading, widespread legacy support
- **ES6 in Node.js:** Future-forward, consistent with browsers, better tooling support

**ğŸ” Module Resolution Intelligence:**
- **Relative imports** (`./utils.js`) â†’ Same project files
- **Absolute imports** (`/src/utils.js`) â†’ From project root
- **Package imports** (`lodash`) â†’ From node_modules
- **Subpath imports** (`lodash/get`) â†’ Specific functionality for smaller bundles

**ğŸ’¡ Professional Decision Making:**
- **New projects:** Use ES6 modules everywhere (modern standard)
- **Legacy Node.js:** CommonJS is fine, gradually migrate to ES6
- **Libraries:** Consider UMD for maximum compatibility
- **Performance-critical:** ES6 with tree shaking for optimal bundle sizes

**ğŸš€ Career Impact:** Understanding these systems makes you valuable on any JavaScript project. You can now work with React (ES6), older Node.js apps (CommonJS), and contribute to open-source libraries (UMD). You're environment-agnostic!

---

## Your Turn! ğŸ’ª Progressive Module Mastery

**ğŸ¯ DEVELOPER'S JOURNEY**: From beginner to pro in 3 progressive challenges!

**ğŸ§  CRITICAL THINKING**: Before each exercise, ask yourself:
- *"What responsibilities does this module have?"*
- *"Should I split this into smaller modules?"*
- *"How would Netflix organize this code?"*

---

{/* prettier-ignore-start */}
### ğŸ¥‰ Level 1: Foundation - String Utilities Module

**ğŸ¤” ARCHITECTURE CHALLENGE**: You're building a blog platform like Medium. Users write articles, create titles, generate URLs...

**PREDICTION QUESTION**: Should string operations be:
**A)** Mixed with user management code?
**B)** In a separate utility module?
**C)** Scattered across different files?

*Think like a professional: Which approach scales to 10 million articles?*

<InteractiveCodeBlock 
  title="ğŸ”§ Build Your First Professional Module" 
  description="CHALLENGE: Can you make these functions work for Medium's blog system?"
  initialCode={`console.log("=== MEDIUM BLOG SYSTEM CHALLENGE ===");
console.log("ğŸ“ Building utilities for the next Medium!");

// ğŸ¯ YOUR MISSION: Complete these functions for a blog platform
const StringUtils = {
  // ğŸ“° Convert article titles to proper case
  titleCase: function(str) {
    console.log("ğŸ”§ Working on:", str);
    // YOUR CODE HERE: Split, capitalize each word, join back
    // Example: "hello world" â†’ "Hello World"
    return str.split(" ").map(word => 
      word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    ).join(" ");
  },
  
  // ğŸ”— Create URL-friendly article slugs
  slugify: function(str) {
    console.log("ğŸ”§ Creating slug from:", str);
    // YOUR CODE HERE: Remove special chars, spaces to dashes, lowercase
    // Example: "Hello World!" â†’ "hello-world"
    return str.toLowerCase().replace(/[^a-z0-9]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
  },
  
  // ğŸ“Š Count words for reading time estimate
  wordCount: function(str) {
    console.log("ğŸ“Š Counting words in article");
    // YOUR CODE HERE: Split by spaces, filter empty strings
    return str.trim().split(/\\s+/).filter(word => word.length > 0).length;
  },
  
  // âœ‚ï¸ Create article previews
  truncate: function(str, maxLength) {
    console.log("âœ‚ï¸ Truncating preview");
    // YOUR CODE HERE: Cut at maxLength, add "..." if needed
    if (str.length <= maxLength) return str;
    return str.substring(0, maxLength) + "...";
  },
  
  // ğŸ” Validate external links in articles
  isUrl: function(str) {
    console.log("ğŸ” Validating URL:", str);
    // YOUR CODE HERE: Check if string looks like a URL
    return str.startsWith("http://") || str.startsWith("https://");
  }
};

console.log("\\n=== TESTING YOUR BLOG SYSTEM ===");

// ğŸ“ Test with realistic blog data
let articleTitle = "how to build amazing web apps";
let articleContent = "Building modern web applications requires understanding modules, components, and architecture patterns.";
let userBio = "John is a full-stack developer who loves creating amazing user experiences.";

console.log("\\nğŸ“° Article Processing:");
console.log("Original title:", articleTitle);
console.log("Formatted title:", StringUtils.titleCase(articleTitle));
console.log("URL slug:", StringUtils.slugify(articleTitle));

console.log("\\nğŸ“Š Content Analysis:");
console.log("Word count:", StringUtils.wordCount(articleContent));
console.log("Reading time:", Math.ceil(StringUtils.wordCount(articleContent) / 200) + " minutes");

console.log("\\nâœ‚ï¸ Preview Generation:");
console.log("Full bio:", userBio);
console.log("Short bio:", StringUtils.truncate(userBio, 50));

console.log("\\nğŸ”— Link Validation:");
console.log("Valid URL?", StringUtils.isUrl("https://medium.com"));
console.log("Invalid URL?", StringUtils.isUrl("not-a-url"));

console.log("\\nğŸ‰ SUCCESS! Your StringUtils module works like a pro!");
console.log("\\nğŸ§  THINK ABOUT IT:");
console.log("âœ… One module, one responsibility (string operations)");
console.log("âœ… Reusable across your entire blog platform");
console.log("âœ… Easy to test each function independently");
console.log("âœ… Team members can work on other modules while you perfect this one!");

console.log("\\nğŸš€ REAL-WORLD IMPACT:");
console.log("- Medium's title formatting: StringUtils.titleCase()");
console.log("- Dev.to's URL slugs: StringUtils.slugify()");
console.log("- Twitter's character limits: StringUtils.truncate()");
console.log("- LinkedIn's link validation: StringUtils.isUrl()");`}
/>

### ğŸ¥ˆ Level 2: Intermediate - Multi-Module Shopping System

**ğŸ¤” COMPLEX ARCHITECTURE CHALLENGE**: You're building Amazon's shopping cart system. Millions of products, thousands of concurrent shoppers, real-time inventory...

**CRITICAL THINKING MOMENT**: 
- Should product validation be mixed with cart management?
- What happens when inventory updates while someone's shopping?
- How does Amazon handle millions of cart operations per second?

**ğŸ¯ MODULE ORGANIZATION QUESTION**: For an e-commerce system, should you have:
**A)** One giant ShoppingModule with everything?
**B)** Separate Product, Cart, and Inventory modules?
**C)** Product module only, put cart logic everywhere?

*Professional insight: Amazon has hundreds of microservices. Each handles one responsibility!*

<InteractiveCodeBlock 
  title="ğŸ›’ Build Amazon-Scale Shopping System" 
  description="CHALLENGE: Architect a system that handles millions of transactions!"
  initialCode={`console.log("=== AMAZON-SCALE SHOPPING SYSTEM ===");
console.log("ğŸ›’ Building the next Amazon! Architecture is everything!");

console.log("\\nğŸ¤” ARCHITECTURAL DECISION:");
console.log("We need separate modules because:");
console.log("- Product team works on catalog");
console.log("- Cart team works on shopping experience");
console.log("- Inventory team works on stock management");
console.log("- Each team deploys independently!");

// ğŸ—ï¸ MODULE 1: PRODUCT SERVICE
console.log("\\nğŸ“¦ PRODUCT SERVICE MODULE:");
const ProductService = {
  create: function(id, name, price, category) {
    console.log("ğŸ“¦ Creating product:", name);
    
    // Validate product data (critical for e-commerce!)
    if (!name || name.length < 3) {
      throw new Error("Product name must be at least 3 characters");
    }
    if (!price || price <= 0) {
      throw new Error("Product price must be positive");
    }
    
    return {
      id: id,
      name: name,
      price: price,
      category: category || "General",
      inStock: true,
      created: new Date().toISOString()
    };
  },
  
  validate: function(product) {
    console.log("âœ… Validating product:", product.name);
    return product.id && product.name && product.price > 0;
  },
  
  applyDiscount: function(product, discountPercent) {
    console.log("ğŸ·ï¸ Applying " + discountPercent + "% discount to", product.name);
    return {
      ...product,
      originalPrice: product.price,
      price: product.price * (1 - discountPercent / 100),
      onSale: true
    };
  }
};

// ğŸ—ï¸ MODULE 2: INVENTORY SERVICE (separate responsibility!)
console.log("\\nğŸ“Š INVENTORY SERVICE MODULE:");
const InventoryService = {
  stock: new Map(), // Real Amazon uses databases, we simulate with Map
  
  setStock: function(productId, quantity) {
    this.stock.set(productId, quantity);
    console.log("ğŸ“Š Stock updated:", productId, "â†’", quantity, "units");
  },
  
  checkAvailability: function(productId, requestedQuantity) {
    const available = this.stock.get(productId) || 0;
    console.log("ğŸ” Checking stock for product", productId + ":", available, "available");
    return available >= requestedQuantity;
  },
  
  reserveItems: function(productId, quantity) {
    const current = this.stock.get(productId) || 0;
    if (current >= quantity) {
      this.stock.set(productId, current - quantity);
      console.log("âœ… Reserved", quantity, "units of product", productId);
      return true;
    }
    console.log("âŒ Insufficient stock for product", productId);
    return false;
  }
};

// ğŸ—ï¸ MODULE 3: CART SERVICE (shopping experience!)
console.log("\\nğŸ›’ CART SERVICE MODULE:");
const CartService = {
  items: [],
  
  add: function(product, quantity = 1) {
    console.log("ğŸ›’ Adding to cart:", product.name, "x" + quantity);
    
    // Check inventory before adding (real-world integration!)
    if (!InventoryService.checkAvailability(product.id, quantity)) {
      return { success: false, error: "Insufficient stock" };
    }
    
    // Check if item already in cart
    const existingItem = this.items.find(item => item.product.id === product.id);
    
    if (existingItem) {
      existingItem.quantity += quantity;
      console.log("ğŸ“ˆ Updated quantity:", existingItem.product.name, "â†’", existingItem.quantity);
    } else {
      this.items.push({ product: product, quantity: quantity });
      console.log("âœ… New item added to cart");
    }
    
    return { success: true, cartSize: this.items.length };
  },
  
  remove: function(productId) {
    console.log("ğŸ—‘ï¸ Removing product", productId, "from cart");
    const initialLength = this.items.length;
    this.items = this.items.filter(item => item.product.id !== productId);
    return this.items.length < initialLength;
  },
  
  updateQuantity: function(productId, newQuantity) {
    console.log("ğŸ“ Updating quantity for product", productId, "â†’", newQuantity);
    const item = this.items.find(item => item.product.id === productId);
    
    if (item) {
      if (newQuantity <= 0) {
        return this.remove(productId);
      }
      
      if (InventoryService.checkAvailability(productId, newQuantity)) {
        item.quantity = newQuantity;
        return true;
      } else {
        console.log("âŒ Not enough stock for requested quantity");
        return false;
      }
    }
    return false;
  },
  
  getTotal: function() {
    const total = this.items.reduce((sum, item) => {
      return sum + (item.product.price * item.quantity);
    }, 0);
    console.log("ğŸ’° Cart total calculated:", "$" + total.toFixed(2));
    return total;
  },
  
  getItemCount: function() {
    return this.items.reduce((count, item) => count + item.quantity, 0);
  },
  
  clear: function() {
    console.log("ğŸ§¹ Clearing cart");
    this.items = [];
  },
  
  getSummary: function() {
    console.log("\\nğŸ“‹ CART SUMMARY:");
    this.items.forEach(item => {
      const lineTotal = item.product.price * item.quantity;
      console.log("- " + item.product.name + " x" + item.quantity + " = $" + lineTotal.toFixed(2));
    });
    console.log("Total items:", this.getItemCount());
    console.log("Total cost: $" + this.getTotal().toFixed(2));
  }
};

console.log("\\n=== AMAZON SHOPPING SIMULATION ===");
console.log("ğŸ›ï¸ Customer Sarah is shopping for her home office setup...");

// Setup inventory (like Amazon's warehouse system)
InventoryService.setStock(1, 50);    // 50 laptops in stock
InventoryService.setStock(2, 200);   // 200 mice in stock
InventoryService.setStock(3, 25);    // 25 monitors in stock

// Create products (like Amazon's catalog system)
let laptop = ProductService.create(1, "MacBook Pro 13-inch", 1299.99, "Electronics");
let mouse = ProductService.create(2, "Wireless Mouse", 29.99, "Electronics");
let monitor = ProductService.create(3, "4K Monitor 27-inch", 399.99, "Electronics");

// Apply Black Friday discount
laptop = ProductService.applyDiscount(laptop, 10); // 10% off

console.log("\\nğŸ›’ SHOPPING EXPERIENCE:");

// Add items to cart
CartService.add(laptop, 1);
CartService.add(mouse, 2);
CartService.add(monitor, 1);

// Customer changes mind about monitor quantity
console.log("\\nğŸ¤” Customer wants 2 monitors...");
CartService.updateQuantity(3, 2);

// Show final cart
CartService.getSummary();

console.log("\\n=== THE MODULE MAGIC ===");
console.log("ğŸ”¥ NOTICE THE SEPARATION OF CONCERNS:");
console.log("âœ… ProductService: Product creation and validation");
console.log("âœ… InventoryService: Stock management and availability");
console.log("âœ… CartService: Shopping experience and cart operations");

console.log("\\nğŸš€ WHY THIS ARCHITECTURE ROCKS:");
console.log("ğŸ‘¥ Different teams can work on each service simultaneously");
console.log("ğŸ”§ Update inventory logic without touching cart code");
console.log("ğŸ§ª Test each service independently");
console.log("ğŸ“ˆ Scale each service based on load (more cart servers vs inventory)");
console.log("ğŸ›¡ï¸ If one service fails, others keep working");

console.log("\\nğŸ§  PROFESSIONAL INSIGHT:");
console.log("This is EXACTLY how Amazon, eBay, and Shopify are built!");
console.log("Each module = potential microservice in production!");`}
/>

### ğŸ¥‡ Level 3: Expert - Full-Stack API Architecture

**ğŸ¤” ENTERPRISE CHALLENGE**: You're the lead architect for the next Facebook. You need to handle user authentication, posts, comments, real-time notifications, file uploads, and analytics. Each feature needs its own API, and they all need to work together flawlessly.

**ğŸ¯ SYSTEMS THINKING CHALLENGE**: 
- How does Facebook handle 3 billion users making API calls simultaneously?
- Should each feature have its own API module or share one giant API handler?
- When the posts API fails, should the entire app break?

**PROFESSIONAL REALITY CHECK**: 
At this level, you're not just writing code - you're designing systems that power the world's largest applications. Your module decisions affect millions of users and entire engineering teams.

**ğŸ§  CRITICAL ARCHITECTURE QUESTION**: For a social media platform, should you have:
**A)** One APIService module that handles everything?
**B)** Separate AuthAPI, PostsAPI, CommentsAPI, NotificationAPI modules?
**C)** No organization, just API calls scattered everywhere?

*Meta (Facebook) insight: They have hundreds of API services, each owned by different teams, each deployable independently!*

<InteractiveCodeBlock 
  title="ğŸš€ Build Facebook-Scale API Architecture" 
  description="EXPERT CHALLENGE: Create an enterprise API system that never fails!"
  initialCode={`console.log("=== FACEBOOK-SCALE API ARCHITECTURE ===");
console.log("ğŸŒ Building APIs for 3 billion users! No pressure! ğŸ˜…");

console.log("\\nğŸ¯ ENTERPRISE REALITY:");
console.log("- Posts API: 50,000 requests/second");
console.log("- Auth API: 30,000 logins/second");
console.log("- Comments API: 25,000 comments/second");
console.log("- File Upload: 10,000 photos/second");
console.log("Each API must be BULLETPROOF!");

// ğŸ—ï¸ BASE API SERVICE (foundation for all APIs)
console.log("\\nğŸ—ï¸ BASE API SERVICE:");
const BaseAPIService = {
  baseUrl: 'https://api.facebook.com/v2.0',
  
  // ğŸ›¡ï¸ Centralized error handling (enterprise-critical!)
  handleError: function(error, operation) {
    console.log("ğŸš¨ API Error in", operation + ":", error.message);
    
    // Real Facebook logs this to monitoring systems
    const errorReport = {
      operation: operation,
      error: error.message,
      timestamp: new Date().toISOString(),
      severity: error.status >= 500 ? 'HIGH' : 'MEDIUM'
    };
    
    console.log("ğŸ“Š Error logged for monitoring:", errorReport);
    return { success: false, error: error.message, reported: true };
  },
  
  // ğŸ”„ Retry logic (when AWS hiccups, keep going!)
  makeRequest: async function(endpoint, options = {}) {
    console.log("ğŸŒ Making request to:", endpoint);
    
    // Simulate real API behavior with random success/failure
    const success = Math.random() > 0.1; // 90% success rate
    
    if (success) {
      return { 
        success: true, 
        data: { message: "API call successful" },
        responseTime: Math.round(Math.random() * 200) + 50 // 50-250ms
      };
    } else {
      const error = { message: "Network timeout", status: 500 };
      return this.handleError(error, endpoint);
    }
  }
};

// ğŸ—ï¸ AUTHENTICATION API MODULE (critical security!)
console.log("\\nğŸ” AUTHENTICATION API MODULE:");
const AuthAPI = {
  ...BaseAPIService, // Inherit base functionality
  
  login: async function(email, password) {
    console.log("ğŸ” Processing login for:", email);
    
    // Input validation (prevent security issues)
    if (!email || !email.includes("@")) {
      return { success: false, error: "Invalid email format" };
    }
    if (!password || password.length < 8) {
      return { success: false, error: "Password must be at least 8 characters" };
    }
    
    const result = await this.makeRequest('/auth/login', {
      method: 'POST',
      body: { email, password }
    });
    
    if (result.success) {
      return {
        success: true,
        token: 'jwt_' + Math.random().toString(36).substr(2, 9),
        user: { id: 12345, email: email, name: email.split('@')[0] }
      };
    }
    
    return result;
  },
  
  validateToken: async function(token) {
    console.log("ğŸ” Validating token");
    const result = await this.makeRequest('/auth/validate', {
      headers: { Authorization: 'Bearer ' + token }
    });
    
    return result.success ? { valid: true, userId: 12345 } : { valid: false };
  },
  
  logout: async function(token) {
    console.log("ğŸ‘‹ Processing logout");
    return await this.makeRequest('/auth/logout', {
      method: 'POST',
      headers: { Authorization: 'Bearer ' + token }
    });
  }
};

// ğŸ—ï¸ POSTS API MODULE (core social functionality)
console.log("\\nğŸ“ POSTS API MODULE:");
const PostsAPI = {
  ...BaseAPIService,
  
  createPost: async function(token, content, media = null) {
    console.log("ğŸ“ Creating new post");
    
    // Validate user is authenticated
    const authCheck = await AuthAPI.validateToken(token);
    if (!authCheck.valid) {
      return { success: false, error: "Authentication required" };
    }
    
    // Content validation
    if (!content || content.length === 0) {
      return { success: false, error: "Post content cannot be empty" };
    }
    if (content.length > 280) {
      return { success: false, error: "Post exceeds 280 character limit" };
    }
    
    const result = await this.makeRequest('/posts', {
      method: 'POST',
      body: { content, media, userId: authCheck.userId }
    });
    
    if (result.success) {
      return {
        success: true,
        post: {
          id: Math.random().toString(36).substr(2, 9),
          content: content,
          userId: authCheck.userId,
          likes: 0,
          comments: 0,
          created: new Date().toISOString()
        }
      };
    }
    
    return result;
  },
  
  getFeed: async function(token, page = 1) {
    console.log("ğŸ“° Loading user feed, page", page);
    
    const authCheck = await AuthAPI.validateToken(token);
    if (!authCheck.valid) {
      return { success: false, error: "Authentication required" };
    }
    
    const result = await this.makeRequest("/feed?page=" + page, {
      headers: { Authorization: 'Bearer ' + token }
    });
    
    if (result.success) {
      // Simulate feed data
      return {
        success: true,
        posts: [
          { id: '1', content: 'Just built an amazing JavaScript module!', likes: 42 },
          { id: '2', content: 'Learning React is so much fun!', likes: 15 },
          { id: '3', content: 'Modular architecture is the future!', likes: 67 }
        ],
        hasMore: page < 3
      };
    }
    
    return result;
  },
  
  likePost: async function(token, postId) {
    console.log("ğŸ‘ Liking post:", postId);
    
    const authCheck = await AuthAPI.validateToken(token);
    if (!authCheck.valid) {
      return { success: false, error: "Authentication required" };
    }
    
    return await this.makeRequest("/posts/" + postId + "/like", {
      method: 'POST',
      headers: { Authorization: 'Bearer ' + token }
    });
  }
};

// ğŸ—ï¸ FILE UPLOAD API MODULE (media handling)
console.log("\\nğŸ“ FILE UPLOAD API MODULE:");
const FileAPI = {
  ...BaseAPIService,
  
  uploadPhoto: async function(token, file) {
    console.log("ğŸ“¸ Uploading photo:", file.name);
    
    const authCheck = await AuthAPI.validateToken(token);
    if (!authCheck.valid) {
      return { success: false, error: "Authentication required" };
    }
    
    // File validation
    const allowedTypes = ['jpg', 'jpeg', 'png', 'gif'];
    const fileExtension = file.name.split('.').pop().toLowerCase();
    
    if (!allowedTypes.includes(fileExtension)) {
      return { success: false, error: "Invalid file type. Allowed: " + allowedTypes.join(', ') };
    }
    
    if (file.size > 10 * 1024 * 1024) { // 10MB limit
      return { success: false, error: "File size must be under 10MB" };
    }
    
    const result = await this.makeRequest('/upload/photo', {
      method: 'POST',
      body: file,
      headers: { 
        Authorization: 'Bearer ' + token,
        'Content-Type': 'multipart/form-data'
      }
    });
    
    if (result.success) {
      return {
        success: true,
        url: 'https://cdn.facebook.com/photos/' + Math.random().toString(36).substr(2, 12) + '.' + fileExtension,
        fileId: 'file_' + Math.random().toString(36).substr(2, 9)
      };
    }
    
    return result;
  }
};

// ğŸ—ï¸ ANALYTICS API MODULE (business intelligence)
console.log("\\nğŸ“Š ANALYTICS API MODULE:");
const AnalyticsAPI = {
  ...BaseAPIService,
  
  trackEvent: async function(event, userId, data = {}) {
    console.log("ğŸ“Š Tracking event:", event, "for user:", userId);
    
    const eventData = {
      event: event,
      userId: userId,
      timestamp: new Date().toISOString(),
      data: data,
      session: 'session_' + Math.random().toString(36).substr(2, 9)
    };
    
    return await this.makeRequest('/analytics/events', {
      method: 'POST',
      body: eventData
    });
  },
  
  getUserStats: async function(token) {
    console.log("ğŸ“ˆ Getting user statistics");
    
    const authCheck = await AuthAPI.validateToken(token);
    if (!authCheck.valid) {
      return { success: false, error: "Authentication required" };
    }
    
    const result = await this.makeRequest('/analytics/user/stats', {
      headers: { Authorization: 'Bearer ' + token }
    });
    
    if (result.success) {
      return {
        success: true,
        stats: {
          postsCreated: Math.floor(Math.random() * 100) + 10,
          likesReceived: Math.floor(Math.random() * 500) + 50,
          commentsReceived: Math.floor(Math.random() * 200) + 20,
          profileViews: Math.floor(Math.random() * 1000) + 100
        }
      };
    }
    
    return result;
  }
};

console.log("\\n=== FACEBOOK APP SIMULATION ===");
console.log("ğŸ‘¤ User Alice is joining the social revolution...");

// Full user journey simulation
async function simulateUserJourney() {
  console.log("\\nğŸš€ COMPLETE USER JOURNEY:");
  
  // Step 1: User Registration/Login
  console.log("\\n1ï¸âƒ£ AUTHENTICATION:");
  const loginResult = await AuthAPI.login("alice@email.com", "securepass123");
  
  if (!loginResult.success) {
    console.log("âŒ Login failed:", loginResult.error);
    return;
  }
  
  console.log("âœ… Login successful! Token:", loginResult.token);
  const userToken = loginResult.token;
  
  // Track login event
  await AnalyticsAPI.trackEvent('user_login', loginResult.user.id);
  
  // Step 2: Create a post
  console.log("\\n2ï¸âƒ£ CONTENT CREATION:");
  const postResult = await PostsAPI.createPost(
    userToken, 
    "Just learned about JavaScript modules! Mind = blown ğŸ¤¯"
  );
  
  if (postResult.success) {
    console.log("âœ… Post created:", postResult.post);
    await AnalyticsAPI.trackEvent('post_created', loginResult.user.id, {
      postId: postResult.post.id,
      contentLength: postResult.post.content.length
    });
  }
  
  // Step 3: Upload a photo
  console.log("\\n3ï¸âƒ£ MEDIA UPLOAD:");
  const mockFile = { name: 'vacation.jpg', size: 2048576 }; // 2MB
  const uploadResult = await FileAPI.uploadPhoto(userToken, mockFile);
  
  if (uploadResult.success) {
    console.log("âœ… Photo uploaded:", uploadResult.url);
  }
  
  // Step 4: Browse feed and interact
  console.log("\\n4ï¸âƒ£ SOCIAL INTERACTION:");
  const feedResult = await PostsAPI.getFeed(userToken);
  
  if (feedResult.success) {
    console.log("âœ… Feed loaded:", feedResult.posts.length, "posts");
    
    // Like a post
    await PostsAPI.likePost(userToken, feedResult.posts[0].id);
    await AnalyticsAPI.trackEvent('post_liked', loginResult.user.id, {
      postId: feedResult.posts[0].id
    });
  }
  
  // Step 5: View analytics
  console.log("\\n5ï¸âƒ£ USER ANALYTICS:");
  const statsResult = await AnalyticsAPI.getUserStats(userToken);
  
  if (statsResult.success) {
    console.log("ğŸ“Š User stats:", statsResult.stats);
  }
  
  console.log("\\n6ï¸âƒ£ SESSION END:");
  await AuthAPI.logout(userToken);
  console.log("ğŸ‘‹ User logged out successfully");
}

// Run the simulation
simulateUserJourney();

console.log("\\n=== ENTERPRISE ARCHITECTURE MASTERY ===");
console.log("ğŸ† CONGRATULATIONS! You've built enterprise-grade APIs!");

console.log("\\nğŸ”¥ NOTICE THE PROFESSIONAL PATTERNS:");
console.log("âœ… BaseAPIService: Shared functionality (DRY principle)");
console.log("âœ… AuthAPI: Security-focused, token validation");
console.log("âœ… PostsAPI: Business logic separation");
console.log("âœ… FileAPI: Media handling specialization");
console.log("âœ… AnalyticsAPI: Data collection and insights");

console.log("\\nğŸš€ ENTERPRISE BENEFITS:");
console.log("ğŸ‘¥ Each API team can work independently");
console.log("ğŸ”§ Update auth logic without breaking posts");
console.log("ğŸ“ˆ Scale each API based on usage patterns");
console.log("ğŸ§ª Test each API service in isolation");
console.log("ğŸ›¡ï¸ If one API fails, others continue working");
console.log("âš¡ Deploy each API service separately");

console.log("\\nğŸŒ REAL-WORLD IMPACT:");
console.log("This architecture powers:");
console.log("- Facebook's 3 billion users");
console.log("- Netflix's streaming platform");
console.log("- Uber's ride-sharing network");
console.log("- Amazon's e-commerce empire");

console.log("\\nğŸ§  YOU'VE LEVELED UP TO ENTERPRISE ARCHITECT!");
console.log("You now think in systems, not just code!");`}
/>
{/* prettier-ignore-end */}

## Key Takeaways

ğŸ¯ **Modules organize code** into reusable, maintainable pieces

ğŸ¯ **Named exports** allow multiple exports per module, **default exports** allow one main export

ğŸ¯ **ES6 modules** (import/export) are the modern standard

ğŸ¯ **Single responsibility** - each module should have one clear purpose

ğŸ¯ **Clear interfaces** - only expose what other modules need to use

ğŸ¯ **Module patterns** like factories and singletons solve common problems

## Quiz Time! ğŸ§ 

You've mastered JavaScript modules! Time to test your knowledge with a quiz.

## What's Next?

Outstanding work! ğŸ‰ You now understand how to organize code with modules. Coming up next:

- **Debugging Techniques** - Find and fix bugs efficiently with developer tools
- **Best Practices** - Professional coding standards and patterns for clean, maintainable code

Keep building well-organized applications! ğŸ’ª