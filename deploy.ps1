# Vibed to Cracked - Windows Deployment Script
# PowerShell version for Windows users

param(
    [string]$Domain,
    [string]$Email,
    [switch]$Help
)

# Colors for output
$Red = "Red"
$Green = "Green"
$Yellow = "Yellow"
$Blue = "Cyan"

function Write-ColorOutput {
    param($Color, $Message)
    Write-Host $Message -ForegroundColor $Color
}

function Show-Help {
    Write-ColorOutput $Blue "üöÄ Vibed to Cracked - Windows Deployment Script"
    Write-Host "=================================================="
    Write-Host ""
    Write-Host "Usage: .\deploy.ps1 [-Domain <domain>] [-Email <email>] [-Help]"
    Write-Host ""
    Write-Host "Parameters:"
    Write-Host "  -Domain    Your domain name (e.g., yourdomain.com)"
    Write-Host "  -Email     Your email for SSL certificates"
    Write-Host "  -Help      Show this help message"
    Write-Host ""
    Write-Host "Example:"
    Write-Host "  .\deploy.ps1 -Domain 'mysite.com' -Email 'admin@mysite.com'"
    Write-Host ""
    exit 0
}

if ($Help) {
    Show-Help
}

Write-ColorOutput $Blue "üöÄ Vibed to Cracked - Deployment Script"
Write-Host "=========================================="

# Check if Docker is installed
try {
    $dockerVersion = docker --version
    Write-ColorOutput $Green "‚úÖ Docker found: $dockerVersion"
} catch {
    Write-ColorOutput $Red "‚ùå Docker is not installed or not in PATH."
    Write-Host "Please install Docker Desktop for Windows first:"
    Write-Host "https://docs.docker.com/desktop/install/windows-install/"
    exit 1
}

# Check if Docker Compose is available
try {
    $composeVersion = docker-compose --version
    Write-ColorOutput $Green "‚úÖ Docker Compose found: $composeVersion"
} catch {
    Write-ColorOutput $Red "‚ùå Docker Compose is not available."
    Write-Host "Please ensure Docker Desktop is running."
    exit 1
}

# Function to prompt for input
function Get-UserInput {
    param($Prompt, $Default = "")
    
    if ($Default) {
        $input = Read-Host "$Prompt [$Default]"
        if ([string]::IsNullOrWhiteSpace($input)) {
            return $Default
        }
    } else {
        $input = Read-Host $Prompt
    }
    return $input
}

# Check if .env.production exists
if (-not (Test-Path ".env.production")) {
    Write-ColorOutput $Yellow "‚ö†Ô∏è  .env.production not found. Let's create it!"
    
    # Get domain and email
    if (-not $Domain) {
        $Domain = Get-UserInput "Enter your domain name (e.g., yourdomain.com)"
    }
    if (-not $Email) {
        $Email = Get-UserInput "Enter your email for SSL certificates"
    }
    
    # Database configuration
    $PostgresPassword = Get-UserInput "Enter PostgreSQL password"
    
    # NextAuth configuration
    Write-ColorOutput $Yellow "Generating NextAuth secret..."
    $NextAuthSecret = [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes([System.Guid]::NewGuid().ToString() + [System.Guid]::NewGuid().ToString()))
    
    # OAuth configuration
    Write-ColorOutput $Blue "üìù You'll need to set up OAuth applications:"
    Write-Host "GitHub: https://github.com/settings/applications/new"
    Write-Host "Google: https://console.developers.google.com/"
    
    $GitHubId = Get-UserInput "Enter GitHub Client ID"
    $GitHubSecret = Get-UserInput "Enter GitHub Client Secret"
    $GoogleClientId = Get-UserInput "Enter Google Client ID"
    $GoogleClientSecret = Get-UserInput "Enter Google Client Secret"
    
    # Stripe configuration
    $StripeSecretKey = Get-UserInput "Enter Stripe Secret Key (optional)" ""
    $StripeWebhookSecret = Get-UserInput "Enter Stripe Webhook Secret (optional)" ""
    
    # Create .env.production file
    $envContent = @"
# Generated by deployment script
DATABASE_URL=postgresql://postgres:$PostgresPassword@db:5432/vibed_to_cracked
POSTGRES_DB=vibed_to_cracked
POSTGRES_USER=postgres
POSTGRES_PASSWORD=$PostgresPassword

NEXTAUTH_URL=https://$Domain
NEXTAUTH_SECRET=$NextAuthSecret

GITHUB_ID=$GitHubId
GITHUB_SECRET=$GitHubSecret

GOOGLE_CLIENT_ID=$GoogleClientId
GOOGLE_CLIENT_SECRET=$GoogleClientSecret

STRIPE_SECRET_KEY=$StripeSecretKey
STRIPE_WEBHOOK_SECRET=$StripeWebhookSecret

EMAIL_FROM=noreply@$Domain
"@

    $envContent | Out-File -FilePath ".env.production" -Encoding UTF8
    
    # Update docker-compose.yml with domain
    (Get-Content "docker-compose.yml") -replace "yourdomain.com", $Domain -replace "your-email@example.com", $Email | Set-Content "docker-compose.yml"
    
    # Update nginx configuration with domain
    (Get-Content "nginx\sites-available\vibed-to-cracked") -replace "yourdomain.com", $Domain | Set-Content "nginx\sites-available\vibed-to-cracked"
    
    Write-ColorOutput $Green "‚úÖ Configuration files updated!"
}

# Enable nginx site (Windows equivalent)
$enabledPath = "nginx\sites-enabled\vibed-to-cracked"
$availablePath = "..\sites-available\vibed-to-cracked"

if (-not (Test-Path $enabledPath)) {
    # Create symbolic link equivalent for Windows
    Copy-Item "nginx\sites-available\vibed-to-cracked" $enabledPath
    Write-ColorOutput $Green "‚úÖ Nginx site enabled"
}

# Build and start services
Write-ColorOutput $Blue "üî® Building and starting services..."
docker-compose up -d --build

if ($LASTEXITCODE -ne 0) {
    Write-ColorOutput $Red "‚ùå Failed to start services. Check the logs with: docker-compose logs"
    exit 1
}

# Wait for services to be ready
Write-ColorOutput $Blue "‚è≥ Waiting for services to start..."
Start-Sleep -Seconds 15

# Run database migrations
Write-ColorOutput $Blue "üóÑÔ∏è  Running database migrations..."
docker-compose exec app npx prisma migrate deploy

if ($LASTEXITCODE -eq 0) {
    Write-ColorOutput $Blue "üå± Seeding database..."
    docker-compose exec app npx prisma db seed
}

# Get domain from environment file
$envFile = Get-Content ".env.production"
$nextAuthUrl = ($envFile | Where-Object { $_ -match "NEXTAUTH_URL=" }) -replace "NEXTAUTH_URL=", ""
$DomainFromEnv = $nextAuthUrl -replace "https://", ""

# Check SSL certificates
Write-ColorOutput $Blue "üîí Checking SSL certificates..."
$certCheck = docker-compose exec -T certbot ls "/etc/letsencrypt/live/$DomainFromEnv" 2>$null

if ($LASTEXITCODE -ne 0) {
    Write-ColorOutput $Blue "üîí Obtaining SSL certificates..."
    docker-compose run --rm certbot
    
    if ($LASTEXITCODE -eq 0) {
        # Reload nginx after getting certificates
        docker-compose exec nginx nginx -s reload
        Write-ColorOutput $Green "‚úÖ SSL certificates obtained and nginx reloaded"
    } else {
        Write-ColorOutput $Yellow "‚ö†Ô∏è  SSL certificate acquisition failed. You may need to configure them manually."
    }
} else {
    Write-ColorOutput $Green "‚úÖ SSL certificates already exist"
}

Write-Host ""
Write-ColorOutput $Green "üéâ Deployment completed!"
Write-Host ""
Write-ColorOutput $Blue "üìã What's running:"
Write-Host "‚Ä¢ Next.js app: https://$DomainFromEnv"
Write-Host "‚Ä¢ PostgreSQL database"
Write-Host "‚Ä¢ Nginx reverse proxy with SSL"
Write-Host ""
Write-ColorOutput $Blue "üìù Useful commands:"
Write-Host "‚Ä¢ View logs: docker-compose logs -f"
Write-Host "‚Ä¢ Stop services: docker-compose down"
Write-Host "‚Ä¢ Update app: docker-compose up --build -d app"
Write-Host "‚Ä¢ Database backup: docker-compose exec db pg_dump -U postgres vibed_to_cracked > backup.sql"
Write-Host ""
Write-ColorOutput $Yellow "üîí Security reminders:"
Write-Host "‚Ä¢ Keep your .env.production file secure"
Write-Host "‚Ä¢ Regularly update Docker images"
Write-Host "‚Ä¢ Monitor your application logs"
Write-Host "‚Ä¢ Set up proper firewall rules on your VPS"
Write-Host ""
Write-ColorOutput $Blue "üåê Next steps:"
Write-Host "1. Point your domain DNS to your VPS IP address"
Write-Host "2. Configure OAuth applications with the correct callback URLs"
Write-Host "3. Test your application at https://$DomainFromEnv"
